<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>（撰写中）JavaScript海底两万里：类</title>
    <link href="/2022/09/06/dive-in-javascript-for-class/"/>
    <url>/2022/09/06/dive-in-javascript-for-class/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的类<code>class</code>。</p><span id="more"></span><hr /><p>在ES6之前，JavaScript中并不存在<strong>类</strong>的概念，开发者们对于原型和继承可谓是绞尽脑汁，通过各种方式来实现基于原型链的继承。</p><p>日常开发中我们经常需要创建许多相同类型的对象，在学习了构造器之后，我们可以想到通过<code>new Function()</code>的形式来实现这种需求。不过在现代JavaScript中引入了更高级的“<strong>类</strong>”的概念，它包含许多适用于面向对象的新功能。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：[[Prototype]]、__proto__、prototype</title>
    <link href="/2022/09/05/dive-in-javascript-for-prototype-s/"/>
    <url>/2022/09/05/dive-in-javascript-for-prototype-s/</url>
    
    <content type="html"><![CDATA[<p>争取一文搞清<code>[[Prototype]]</code>、<code>__proto__</code>、<code>prototype</code>的区别与联系。</p><span id="more"></span><hr /><p>在学习JavaScript原型相关内容时，包含"proto"的属性着实不少，各自都有不同的含义。</p><h2 id="prototype">[[Prototype]]</h2><p><code>[[Prototype]]</code>是<strong>对象的隐藏属性</strong>，可以认为是一个<strong>概念</strong>，表示该对象的原型。</p><h2 id="proto"><strong>proto</strong></h2><p><code>__proto__</code>是<strong>JavaScript提供的访问对象原型的方式</strong>，通过<code>obj.__proto__</code>可以访问到<code>obj</code>的原型，只不过现代JavaScript更加推荐使用<code>Object.getPrototypeOf(obj)</code>和<code>Object.setPrototypeOf(obj, [descriptors])</code>来获取和设置对象<code>obj</code>的原型。</p><h2 id="prototype-1">prototype</h2><p><code>prototype</code>是针对函数而言的，只有函数才有这个属性。比如<code>F</code>是一个构造函数，对于<code>F.prototype</code>，<code>F.prototype = protoObj;</code>表示<strong>当创建了一个<code>new F</code>时，新对象的<code>[[Prototype]]</code>会被赋值为<code>protoObj</code>，也就是<code>F.prototype</code></strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> protoObj = &#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = protoObj;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <span class="hljs-comment">// obj.__proto__ === F.prototype</span><br></code></pre></td></tr></table></figure><p>简单来说，<code>F.prototype</code>就是调用构造函数<code>F</code>时创建的对象的原型，可以认为这个“原型”是对象的<strong><em><u>模板</u></em></strong>，这与Java中<strong>类是对象的模板</strong>的理念同样非常相似。</p><h2 id="原型与原型继承">原型与原型继承</h2><p>我们必须要区分这两个概念：构造方法的原型属性<code>F.prototype</code>是一个模板，它可以创建以此为参考的新对象；原型继承表示多个类之间的继承关系，通过<code>__proto__</code>可以读取和设置某个对象的<code>[[Prototype]]</code>属性，即设置该对象的父类。</p><h2 id="一个例子">一个例子</h2><p>对于两个构造方法<code>Parent</code>和<code>Child</code>，<code>Child</code>从<code>Parent</code>继承，我们可以通过<code>new Parent()</code>和<code>new Child</code>来创建两个对象<code>parent</code>和<code>child</code>。</p><p>于是，我们可以得到以下推论：</p><ul><li><code>child.__proto__ === parent === Parent.prototype</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：原型(链)</title>
    <link href="/2022/09/03/dive-in-javascript-for-prototype/"/>
    <url>/2022/09/03/dive-in-javascript-for-prototype/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的原型(链)。</p><span id="more"></span><hr><p>Java选手们很容易看出来，如果存在三个类<code>User</code>、<code>Admin</code>、<code>Guest</code>，这三个类之间可以存在继承关系，像这样：</p><pre><code class=" mermaid">flowchart BTAdmin --&gt;|&quot;[[Prototype]]&quot;| UserGuest --&gt;|&quot;[[Prototype]]&quot;| User</code></pre><p>在JavaScript中，<strong>原型继承</strong>可以用来实现对象继承的能力。</p><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a><code>[[Prototype]]</code></h2><p>在JavaScript中，对象有一个<strong>隐藏属性</strong><code>[[Prototype]]</code>，称为<strong>“原型”</strong>，它要么是<code>null</code>，要么是另一个对象的<strong>引用</strong>。</p><p>当我们从对象中读取一个<strong>缺失的属性</strong>，JavaScript会从原型中获取该属性，这称为<strong>“原型继承”</strong>，我们后面细看。</p><p>所谓<strong>隐藏属性</strong>，指<code>[[Prototype]]</code>是对象内部的，而且是隐藏的，可以说相当于Java中的private字段。</p><p>但就如同Java中可以设置<code>getter/setter</code>方法一样，JavaScript中也存在设置<code>[[Prototype]]</code>的方式，不过不同于Java中通过<code>extend</code>关键字来实现继承，一种方法是使用<code>__proto__</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>    <span class="hljs-attr">jump</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>rabbit.<span class="hljs-property">__proto__</span> = animal; <span class="hljs-comment">// 此时rabbit的原型被设置为animal</span><br></code></pre></td></tr></table></figure><p>现在，如果执行<code>console.log(rabbit.eats)</code>，JavaScript引擎会顺着<code>[[Prototype]]</code>引用，从原型链中寻找<code>eats</code>属性。</p><p>不止访问属性，当访问对象中不存在的函数，JavaScript引擎也会从原型中寻找这个函数。</p><p>如果存在这样一条原型链：</p><pre><code class=" mermaid">flowchart BTShortHair --&gt;|&quot;[[Prototype]]&quot;| Cat --&gt;|&quot;[[Prototype]]&quot;| Animal</code></pre><p>当我们从<code>ShortHair</code>中读取一些它不存在的内容，那么JavaScript会先从<code>cat</code>中查找，然后在<code>animal</code>中查找。</p><p>原型链中存在两个限制：</p><ol><li>引用<strong>不能形成闭环</strong>，如果在闭环中分配<code>__proto__</code>，JavaScript会报错。</li><li><code>__proto__</code>的**值只能是对象或<code>null</code>**，其他的类型都会被忽略。</li></ol><p>与Java相同，JavaScript也是<strong>单继承</strong>的。</p><p><strong>但是事实上<code>__proto__</code>有点过时了，它是<code>[[Prototype]]</code>的<code>getter/setter</code>，现代JavaScript建议使用<code>Object.getPrototypeOf/Object.setPrototypeOf</code>来取代<code>__proto__</code>，这两个函数后面再说。</strong></p><blockquote><p>在这里需要了解一下**<code>getter/setter</code><strong>，它们也属于对象的属性，称为</strong>访问器属性<strong>，本质上是一类</strong>用于获取和设置值的函数**，但看起来就像常规属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">propName</span>() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">propName</span>() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是，在读取obj.propName时，getter起作用；在设置obj.propName时，setter起作用。</p><p>比如这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">surname</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.surname&#125;</span>`</span>;<br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">name</span>) &#123;<br>        [<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>] = name.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;;<br><br>user.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;John Smith&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">fullName</span>); <span class="hljs-comment">// John Smith</span><br></code></pre></td></tr></table></figure><p>这样我们就设置了一个“虚拟”属性<code>fullName</code>，可以对其进行读写操作。</p><hr><p>属性具有三个<strong>属性标志</strong>：</p><ul><li><code>writable</code>：如果为<code>true</code>，则值可以被修改，否则为只读。</li><li><code>enumerable</code>：如果为<code>true</code>，会被在循环中列出。</li><li><code>configurable</code>：如果为<code>true</code>，则此属性可以被删除。</li></ul><p>而相较于普通的属性标志，<strong>访问器属性</strong>没有<code>value</code>和<code>writable</code>标志，这很好理解，<code>get</code>和<code>set</code>的存在就是读取与设置<code>value</code>，同时<code>set</code>是否存在也就决定了一个属性是否<code>writable</code>。</p></blockquote><h2 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h2><p>在<a href="https://skycurtain-dreamland.netlify.app/2022/09/01/dive-in-javascript-for-constructor/">上一篇</a>中我们可以知道，通过<code>new F()</code>的语法可以用构造函数创建一个新对象，而对于构造函数<code>F</code>，如果为它设置属性<code>F.prototype</code>的值是一个对象，那么当执行<code>let obj = new F();</code>时，<code>new</code>操作符会使用<code>F.prototype</code>为新对象<code>obj</code>设置<code>[[Prototype]]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = aniamal;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-property">eats</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面的代码中，<code>Cat.prototype = aniamal;</code>的意思是当<code>new Cat(...)</code>时，把新对象的<code>[[Prototype]]</code>赋值为<code>animal</code>。</p><p><strong>注意</strong>，<code>F.prototype</code>是<code>F</code>的一个名为<code>&quot;prototype&quot;</code>的属性，这是<strong>每个函数都有的属性</strong>，而不是代表<code>F</code>的原型，并且<code>F.prototype</code>的变化对已经创建出来的对象时没有作用的。</p><p>默认情况下，<code>F.prototype</code>是一个只有属性构造器的对象，构造器指向函数自身。</p><h2 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h2><p><code>&quot;prototype&quot;</code>属性在<code>JavaScript</code>的底层有广泛的应用，所有的内建函数都用到了它。</p><p>不愧叫<code>JavaScript</code>，在原型这方面，它的思想跟<code>Java</code>的<code>Object</code>类也有异曲同工之妙：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title function_">alert</span>(obj); <span class="hljs-comment">// [object Object]</span><br></code></pre></td></tr></table></figure><p>我们创建了一个空对象<code>obj</code>，但还是可以看到成功输出了<code>obj</code>的信息，那么很明显是内建的<code>toString</code>函数运行的结果，但是它在哪里呢？</p><blockquote><p>注意，如果用<code>console.log()</code>输出<code>obj</code>，那么在命令行只会看到<code>&#123;&#125;</code>表示空对象，只有通过<code>alert()</code>才能在浏览器中看到<code>[object Object]</code>弹窗。</p><p>默认情况下，<code>toString()</code>方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code>返回 <code>&quot;[object type]</code>“，其中<code>type</code>是对象的类型。</p><p>所以，<code>[object Object]</code>就表示Object对象。</p></blockquote><p>我们知道<code>let obj = &#123;&#125;;</code>与<code>let obj = new Object();</code>是一样的，而<code>new Object()</code>是一个构造函数的调用，<strong>Object的<code>prototype</code>指向一个包含一堆方法的对象，当然也包括了<code>toString()</code><strong>，这与Java中</strong>Object作为所有类的父类</strong>的理念有所雷同，所以，当<code>new Object()</code>被调用或<code>&#123;&#125;</code>被创建，这个对象的<code>[[Prototype]]</code>就会被设置为<code>Object.prototype</code>，而<code>toString()</code>方法正是从中获取的。其他的内建对象像Array、Date等等也都在prototype上挂载了方法。</p><p>按照规范，<strong>所有的内建原型顶端都是<code>Object.prototype</code><strong>，所以才会有“</strong>一切都是从对象继承而来</strong>”的说法。</p><p>对于基本类型，同样与Java很像，JavaScript提供了临时包装器在试图访问它们的属性时通过内建构造器<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>创建，使开发者能够操作字符串、数字、布尔值，“临时”意味着这些包装器在操作结束后就会被垃圾回收器回收。</p><p>原生的原型可以被修改，但是非常不建议这么做，因为会导致严重的冲突问题，除非需要在久JavaScript环境中实现新标准的方法，这被称为polyfilling。</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><p>之前说过，通过<code>obj.__proto__</code>设置&#x2F;读取原型已经是过时的方法了，现代JavaScript中推荐通过以下方式来实现：</p><ul><li><code>Object.getPrototypeOf(obj)</code> —— 返回对象<code>obj</code>的原型</li><li><code>Object.setPrototypeOf(obj, proto)</code> —— 将对象obj的原型设置为proto</li></ul><p>此外，通过<code>Object.create(proto, [descriptors])</code>可以利用规定的proto作为原型以及可选的描述属性来创建一个新对象。这个方法非常强大，因为可以为对象添加额外的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal, &#123;<br>  <span class="hljs-attr">jumps</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-title function_">alert</span>(rabbit.<span class="hljs-property">jumps</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>还可以实现一种浅拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj),<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure><p>使用 <code>Object.create(null)</code> 或 <code>&#123;__proto__: null&#125;</code> 还可以创建无原型的对象,这些对象被用作字典，以存储任意（可能是用户生成的）键。</p><p>通常，对象会从 <code>Object.prototype</code> 继承内建的方法和 <code>__proto__</code> getter&#x2F;setter，会占用相应的键，且可能会导致副作用。原型为 <code>null</code> 时，对象才真正是空的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：构造器</title>
    <link href="/2022/09/01/dive-in-javascript-for-constructor/"/>
    <url>/2022/09/01/dive-in-javascript-for-constructor/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的构造器。</p><span id="more"></span><hr /><h2 id="构造器">构造器</h2><p>在JavaScript中，我们通常使用<code>let obj = &#123;...&#125;;</code>的方式来创建一个对象，或者是通过<code>let obj = new Object();</code>的方式，前者属于字面量的方式，而后者就是本篇要聊的话题之一—— 构造器<code>Constructor</code>。</p><p>常规的<code>&#123;...&#125;</code>语法允许创建一个对象，然而有时候需要创建很多类似的对象，例如多个用户或者菜单项等等，这类需求可以通过构造函数与<code>"new"</code>操作符来实现。</p><p>构造函数在技术上与常规函数相同，但是存在两个<strong>约定</strong>（不是规定）：</p><ol type="1"><li>它们的命名以大写字母开头</li><li>它们只能由<code>"new"</code>操作符来执行</li></ol><p>一个例子可以像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br></code></pre></td></tr></table></figure><p>这跟Java的构造方法其实有几分相似之处。在Java中，我们通过<code>new</code>一个<code>class</code>的方式在创建一个对象，实际上Java会调用这个类的构造方法来创建对象。而在JavaScript中，我们不需要像Java那么规范地先写<code>class</code>再写构造方法，<strong>JavaScript的构造函数能够在通过<code>new</code>操作符执行时候创建一个新的空对象并分配给<code>this</code></strong>，函数体中的内容会修改<code>this</code>的属性，最后返回<code>this</code>。</p><p>技术上来说任何函数都可以作为构造器，但箭头函数除外，它没有自己的<code>this</code>。</p><p>对于最后“返回<code>this</code>”的这个步骤，其实是解释器帮助我们完成的，因为我们不需要显式地写出<code>return</code>语句，但并非不允许在里面写<code>return</code>。<code>return</code>语句存在一条规则：如果<code>return</code>返回一个对象，那么就返回这个对象，其他情况都返回<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;; <span class="hljs-comment">// 返回一个对象</span><br>&#125;<br><br><span class="hljs-keyword">let</span> newUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newUser); <span class="hljs-comment">// &#123; name: &#x27;Jack&#x27; &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回非对象</span><br>&#125;<br><br><span class="hljs-keyword">let</span> newUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newUser); <span class="hljs-comment">// User &#123; name: &#x27;John&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p>所以用构造函数来创建对象具有很大的灵活性，其实这跟Java还是比较类似的，可以暂时参考Java的类来理解JavaScript的构造函数，所以构造函数中不仅可以添加属性，也可以添加方法，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, my name is John.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从反馈bug到想造轮子</title>
    <link href="/2022/08/29/from-reporting-bugs-to-wish-inventing-wheels/"/>
    <url>/2022/08/29/from-reporting-bugs-to-wish-inventing-wheels/</url>
    
    <content type="html"><![CDATA[<p>开发者的自己的项目中，是否应该在第三方类库的引用上保持最大程度的洁癖呢？</p><span id="more"></span><hr /><p>自从<del>宇宙第一Markdown编辑器</del><strong>Typora</strong>宣布收费后，我始终没有下定决心购买正式版，一是由于付费后获得的能力和解锁的功能并不是我必须的，二是因为我发现了不错的vscode插件，基本可以胜任我写内容的场景，并且Markdown对我来说目前的作用就是写博客，而在vscode中事实上能够更加一体化地管理博客。</p><p>然而用了几个月我都没有发现这个插件居然不支持用于设置摘要的<code>&lt;!-- more --&gt;</code>，发现时是因为看到首页中所有文章的摘要都失效了。</p><blockquote><p>在文章中使用 <code>&lt;!-- more --&gt;</code>，那么<code>&lt;!-- more --&gt;</code>之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p></blockquote><p>因为我习惯于为文章添加一句引子，也就是正文的第一句，不支持摘要的结果是引擎会截取尽可能多的字数作为摘要，虽无伤大雅，但总归不爽。不过我发现作者更新频率还是很高的，于是便打算等几天，但并没有发现更新了对Hexo摘要的支持，看来我这个社恐只能发邮件向作者反馈一下了，可是得到的回复是：</p><blockquote><p><strong>插件的原理是解析Markdown语法，因此一切非Markdown语法的内容都会被忽略</strong>。</p></blockquote><p>很可惜，看来作者的开发思路跟Typora有所不同，但这也怪不得开发者，毕竟是用爱发电的作品，作者必然是以满足自己的使用需求为第一要义，除非给钱让开发者定制，不然也很难去提什么主观的要求。</p><p>虽然还在学习前端的我在开发vscode插件这方面没什么能力，但是此刻却萌生了想要开发一款Markdown编辑器的欲望。</p><p>不过很幸运，我发现了另一款插件，同样能够满足我写博客的需求，然而在更新了一个版本之后出现了一些主题适配的问题，并且同样没有发现修复更新，很无奈我再一次发邮件向开发者反馈，这一次的反馈很顺利，作者也是邮箱高强度在线，讲清楚问题后20分钟就修复了bug并推送新版。</p><p>很开心，但同时我也在思考，如果这位开发者没有排查出问题，甚至没有回复我，那么这些插件对我来说使用体验就会大打折扣了，所以我还是有想自己开发Markdown编辑器的欲望。</p><hr /><p>这就是程序员们常说的“造轮子”了，而且是重复造轮子，因为已经有了功能相似甚至相同的产品出现。造轮子的初衷实际上是源于自己对现有产品的不满足，比如功能无法完整覆盖自己的需求，比如已经失去维护很长时间，甚至是业界并没有符合自己设想的项目……但是我时常在想，当在自己的项目中引入了这些开源的库之后，如果这些库出现了问题，就像fastjson频繁曝出安全漏洞，此时该自己从头实现一套专属当前场景的工具库还是继续另寻其他开源库呢？</p><p>对我来说，我觉得自己是有一些代码洁癖的，对源码的好奇让我时常会思考某个功能在底层是如何实现的，有时还会尝试去实现标准库的某个函数，但是当我在前几个学期完成大作业的过程中，却对手写工具类有所排斥，果断地暂时将底层原理抛诸脑后，对现成的工具和类库，只要能实现需求，便只管拿来主义。事实上我是有些惭愧的，然而大作业是要实现需求的，需求只是一句话，是不会考虑业务逻辑的复杂度的，此时实现需求才是第一要义，调用的库存在什么关键细节并不需要考虑，因为类库就应该由它的开发者来维护。</p><p>不过我总觉得这看来像是自己的项目中有一些关键内容被别人握在手里，虽然开源协议可以保护自己的软件不会遭到类库开发者的“制裁”，但调用别人写的代码总是感到不够安心，如果是一些嵌入项目比较深的组件，原作者进行了改动后很可能自己要跟着修改很多逻辑，这种被动想必不会那么自在。</p><p>就我个人的感受来看，这是一种复杂的心理，当在完成一个任务的过程中，我通常是属于只看结果的那一类人，只要有可以实现需求的方案，那就可以拿来用，而不考虑是否有必要总结出一套代码库出来，在当下的网络世界，几乎所有在开发过程中遇到的问题都能够寻找到答案。</p><p>而当我在酝酿自己的项目时，往往想要追求<strong>每一行代码都来自于自己的双手在键盘上的敲击</strong>，不论业界是否存在一些成熟的解决方案。自己的项目，我就希望所有的东西都是我自己手搓出来的，当然，即便一时半会为了开发进度而需要引入一些现成的库，在未来我也愿意重新实现项目中调用的函数，当项目中所有的代码都是我自己的劳动成果，我才踏实地感到这是我自己的产品，我是有完整的决定权和发言权的。</p><hr /><p>我有不少次提到过自己有个人项目的点子，但需要一定开发经验的积累，以及各类开发工具的使用，还包含一些方面的底层原理，因为我想掺一脚的是一个必然冷门也必然缺少支持的方向：<strong>手机编程</strong>。</p><p>作为一个有想法<del>没技术</del>(会有的)的入门级开发者，我一直很能<strong>理解非科班但也要学习编程而又不以此为职业</strong>的朋友们，学习编程语言的第一步不是写一个<code>Hello World!</code>，而是先要进行繁琐的环境配置，对于不是有志于学习一门编程语言的朋友们，这个过程就能够磨灭一半的学习兴趣，更不用说还能否发现编程的乐趣了，甚至即便能够为学习生活工作带来效率的提升，也会本能地排斥。</p><p>而作为 [半]个科班人，每一次重装系统或者学习新的开发技能时，也会因为搭建环境的繁复而恼火，如果是重装系统加上重新安装常用软件以及配置好所有的开发环境，基本上完整的一天时间就这么过去了，所以久而久之我的态度也转变为能忍则忍，能凑活用就不重装系统。</p><p>所以早在属于我的<code>Hello World!</code>时代，我就在思考<strong>是否存在用手机编写和运行代码的可能性</strong>，让我意想不到的是居然真的有，当年有不少大佬都在探索手机编程的可行性，而基于Linux内核的Android系统也无疑是最有希望做到这一点的。当年也确实有很多人凭借这类APP入门了编程，但这始终是一个冷门的领域，冷嘲热讽的声音从未停止过，且必须承认的是手机编程也真的无法达到PC平台上各种IDE的高度，不论从硬件还是软件，移动设备的能力都难以与PC相提并论。年复一年中，很多APP都逐渐失去了维护，但也有新开发者关注到了这个又偏又怪的场景，所以这些年来手机编程一直保持着一种小众的状态。</p><p>对我来说，我始终认为手机编程是有实用性的，因为相较于在PC上配置繁琐的环境变量和进行复杂的设置，在移动设备上安装即用的体验对入门编程的人群来说是一个能够保持住兴趣和好奇心的绝佳方式。而在当下，大屏设备也逐渐兴起，我相信在手机和平板上写代码会成为编程初学者的选择之一。</p><p>尽管它必然的小众决定了它不可能成为生产力的主流，我更不可能靠它来养活自己，但我知道有很多人都曾遇到这个痛点，而这就足以让我坚信，一款针对移动端的开发平台就是从我学习计算机以来最想造的轮子。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>答辩之殇</title>
    <link href="/2022/06/09/mourning-of-defense/"/>
    <url>/2022/06/09/mourning-of-defense/</url>
    
    <content type="html"><![CDATA[<p>这些老学究们到底对什么样的答辩项目更感兴趣呢？</p><span id="more"></span><hr /><h2 id="idea的夭折">idea的夭折</h2><p>炼丹机器学习要求凌驾于热门行业的创新点（本科预言家是吧），管理系统又认为没有含金量转而极其要求界面的美观（自己招标的教务系统不也丑得极具个性），本应体现唯性能论的项目却成为了面向普通用户设计的系统性软件（为什么有些优秀的分析器根本没有UI），使用当下主流的开发框架又被质疑如此平平无奇的信管系统是否需要那么多前后端框架提供支持（造不造轮子都没好话），同时数据库设计又变成了没有含金量的步骤（不做好设计被开除八百次都死有余辜），而代码量甚至也会成为评价指标之一（把框架源码也算进去行不行）······有些<strong>满含金点子</strong>的项目，很可能就在无情的毒打之中被扼杀在摇篮。</p><blockquote><p>这些奇怪的建议真的能够为<strong>高校向社会输送人才</strong>的理念提供一点利好吗？</p><p>这些大部分早已与主流技术栈脱轨的老学究们真的能够拓展大学生的视野吗？</p><p>人人做研究，难道就一定会提高全国的研究水平吗？</p></blockquote><h2 id="当我们答辩时我们在干什么">当我们答辩时我们在干什么</h2><p>这学期中在自己经历了三场课程项目答辩，有幸看过隔壁专业的毕业设计答辩，网上冲浪看到一些学生网友的答辩实录，以及参观了身处新兴一流高校的朋友的课程项目答辩后，我难以抑制自己产生上述的疑问。</p><p>在我看来，任何一套有助于提升开发者工作效率的开发框架都是其背后或个人或团队的技术与智慧的结晶，开发框架使大量的开发者不用关注大量操作系统底层与网络底层的实现细节，关注于业务功能的实现就好，然而在使用了开发框架后，你的项目很有可能就会变成“工作量不够”，而事实上，当我学通了计算机网络、操作系统，用几门程序语言硬是从底层造出了一个功能，写了上千行代码，得到的评价又会变成“这不都有现成的库吗？你自己写出来有什么新意呢？”。所以也可以说是学生们变聪明了，我们知道要想办法去做一些集合了一大堆功能的app，最好是一个网站服务，于是很自然地，学生们都想到了各种管理系统。</p><p>但久而久之，学生们也苦于老师们看腻了各种管理系统，于是项目的思路设计开始往热门的机器学习、模式识别，智能决策这些方面去靠，但是这类建立在大量学科基础知识上的应用又岂是我辈普普通通的本科生能够速成的，况且辛苦造出来的“轮子”也大概率比不上大厂造出来的“车”，那不如直接去找现成的模型或API集成到自己的平平无奇管理系统，于是评价又变为“你们的理解好像有点问题”或是“你们的数据集和模型是怎么来的？”这样暴露本质的问题。</p><p>看来不论是什么样的项目，哪怕是比得上一线互联网大厂的app产品，答辩上都会收到一些无趣、无理的问题。于是逐渐地，答辩就成为了一场<strong>如何把老师忽悠转</strong>的表演赛，用高级的话术、包装的语言，让评委老师认为这是及其有前景的项目，自己恨不得掏几百万出来投资入股，那你的表演就差不多到位了，成绩也就基本令人满意了。说来可笑，有点像是骗融资的，其实不假，毕竟有些高校工作者也是毕生追求科研经费呢。</p><p>所以，当我们答辩时我们在干什么？在最近的一场线上答辩，我们小组在从答辩开始到轮到我们组的两个多小时中，一边听着大会一边开着小会，进一步测试项目功能实现的同时盘点前面各小组项目得到的评价，以此来调整我们投屏演示时的话术，注意说话的细节，注意避开前面小组遇到的坑······很幸运，一路下来还算顺利，只是感到一点都不自在。</p><h2 id="软件项目的答辩需要什么">软件项目的答辩需要什么</h2><p>仅在我看来，也仅从计算机相关专业来看，我所遇到的老师中，有很多都没有当下软件技术的工程经验，在很多专业相关的课程中，我几乎没有听到过任何与“公司”“工程”相关的词汇和字眼，我愿意相信他们并非不学无术，也许在学术研究与工程应用中间真的存在一堵很厚的高墙，这些老师能把理论理解得极为透彻，而他们对工程应用的理解或许还在十年之前，当我们用上新的程序语言、新的开发框架、新的UI组件，老师们就很难针对项目本身提出问题和建议了。当然，也有很多老师，相比之下他们就有明显的开发经验，至少这些老师敲起代码是十分熟练的。我们时常抱怨，如果是他们来带我们的课设就好了，但为什么不是呢？或许是他们的级别不够吧。</p><p>总有人说，计算机专业的核心是哪些亘古不变的计算机原理，以及形成一种计算机思维和素养，编程语言并不是第一要义。但事实上，程序代码的地位应当是计算机动态运行的一种静态体现，这是很重要的角色。作为高校鄙视链中的一员，我们对高职时常有一种理所当然的自信，但我们经常能够在一些比赛中名单中看到，这些来自“培训班”的创意往往出乎我们意料。如果说教授亘古不变的计算机原理是大学胜于高职的地方，那么实践项目的古板、陈旧就像开着一辆慢吞吞的老爷车在高速公路上，没有人会羡慕你的历史价值，别人只会嘲笑你跑得太慢。</p><p>纸上谈兵式的项目实践不应该是有志于成为开发者的我们的追求，经典的计算机理论不能永远通过古董项目来作为实操，反正即便是<strong><em>最新</em></strong>的开发技术也依然要靠学生<strong><em>自学</em></strong>，只是如果在教学指导上能够给出方向，那就业市场将感激不尽。</p><p>我在<ahref="https://skycurtain-dreamland.netlify.app/2021/09/19/0919-thinking/">0919：随想|Skycurtain.Dreamland</a>中表示，只要讲座内容合理，我还是比较青睐这种讲座＋项目的模式，而这种模式放在用于所有的计算机课程设计，也应当合理。</p><h2 id="后记">后记</h2><p>2022-06-13</p><p>看到一个知乎问题：</p><blockquote><p>如何评价领导要用代码行数衡量每个人的工作量？</p></blockquote><p>有一个回答是这样：</p><blockquote><p>用代码量来考核程序员，</p><p>相当于用油耗高低来评价汽车，但却以为油耗高的汽车好</p><p>相当于用煤气用量来评价厨师，认为谁用的煤气多，谁更努力（结果不做饭的时候，炉子也在燃烧）</p><p>相当于用药方里药的数量来评价医生，认为药开得多的医生，更努力（讽刺的是，医院真这么干）</p><p>相当于用“送一单外卖”所花的时间来评价外卖员，“人家送了十分钟，你却只送了三分钟，你凭什么少干七分钟活？”</p><p>相当于用作业量来评价老师，学生要是有做不完的作业，那这就是一位好老师</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我感觉良好的死循环妙用：多线程协作</title>
    <link href="/2022/05/21/charm-of-endless-loop-in-multithreading/"/>
    <url>/2022/05/21/charm-of-endless-loop-in-multithreading/</url>
    
    <content type="html"><![CDATA[<p>还未曾想过死循环的条件break机制能在流程控制以外的场景中焕发光彩。</p><span id="more"></span><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>有四个线程，每个线程函数都能够接收三个整型变量（变量的值在创建线程时设定），在线程内部求出三个变量的和，在四个线程都计算完毕后，要求必须在main函数中对四个线程的计算结果再次求出总和，然后在各个线程中分别输出这个总和值。</p></blockquote><h2 id="方案逻辑"><a href="#方案逻辑" class="headerlink" title="方案逻辑"></a>方案逻辑</h2><p>程序开始运行后，主线程与子线程的协作可以这样描述：</p><blockquote><ol><li>子线程计算变量之和，主线程进入死循环，检测子线程是否计算完成。</li><li>子线程计算完成时，主线程计算总和并跳出循环，此时子线程进入死循环，检测主线程是否计算完成。</li><li>主线程计算完成后即结束运行，各个子线程输出总和。</li></ol></blockquote><p>两种检测都各需要一个flag作为判断条件，而且需要一个共享的空间用于保存子线程和主线程计算的结果，在需要取用时从中获取即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Thread[] thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= thread.length; i++)<br>            thread[i - <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(i, i, i));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= thread.length; i++)<br>            thread[i - <span class="hljs-number">1</span>].start();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.isSubFinished()) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sub : Data.getArrayList())<br>                    Data.setSum(Data.getSum() + sub);<br>                Data.finishSum();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Task.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> c;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b + c;<br>        Data.addList(sum);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.getListLength() == <span class="hljs-number">4</span>) &#123;<br>                Data.finishSub();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.isSumFinished()) &#123;<br>                System.out.println(<br>                    <span class="hljs-string">&quot;In &quot;</span> +<br>                    Thread.currentThread().getName() +<br>                    <span class="hljs-string">&quot;, the sum is: &quot;</span> + Data.getSum()<br>                );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flagSub</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flagSum</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addList</span><span class="hljs-params">(Integer sum)</span> &#123;<br>        arrayList.add(sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">getArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getListLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arrayList.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSum</span><span class="hljs-params">(<span class="hljs-type">int</span> sum)</span> &#123;<br>        Data.sum = sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishSub</span><span class="hljs-params">()</span> &#123;<br>        flagSub = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishSum</span><span class="hljs-params">()</span>&#123;<br>        flagSum = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubFinished</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flagSub;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSumFinished</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flagSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">In</span> Thread-<span class="hljs-number">1</span>, the sum is: <span class="hljs-number">30</span><br><span class="hljs-attribute">In</span> Thread-<span class="hljs-number">0</span>, the sum is: <span class="hljs-number">30</span><br><span class="hljs-attribute">In</span> Thread-<span class="hljs-number">3</span>, the sum is: <span class="hljs-number">30</span><br><span class="hljs-attribute">In</span> Thread-<span class="hljs-number">2</span>, the sum is: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程起步：矩阵乘法的任务分配</title>
    <link href="/2022/04/27/tasks-assignment-method-in-parallel-matrix-multiplication/"/>
    <url>/2022/04/27/tasks-assignment-method-in-parallel-matrix-multiplication/</url>
    
    <content type="html"><![CDATA[<p><del>操作系统</del>多线程编程课程设计完工后记</p><span id="more"></span><hr><p>多线程确实是很浪漫的一个话题，不过在我还没有了解到更底层内容的现在，这种需要做性能分析的工作我还是不要尝试用Java这种高级抽象的虚拟机语言吧吧吧吧吧吧。</p><p>我不得不吐槽一下这个所谓的操作系统课程设计，题目不是要求实现线程安全的数据结构就是要求实现多线程需求的性能分析，在我看来这完全就是应用层面的东西，完全跟底层实现没有一点关系。在去年我曾留意过操作系统课设的要求，那时候还是要求学生去模拟操作系统的某些调度算法，今年估计是要冲什么业绩，把大纲改得又红又专不说，题目被改成这个样子，指导老师也是一言难尽。但话说回来也没有什么办法，固然有些勇士是敢于等到之后再考虑修这门课，但我不太愿意将本不该有任何课程的学期添上一件本该可以半年前就搞定的破事，于是便开始了为期2周的多线程编程学习。</p><p>考虑课设要求进行性能分析，所以权衡之下我选择了并行矩阵乘法，毕竟是学过的数学知识，相当于业务需求已经烂熟于心，只需要学好多线程就可以开工。</p><blockquote><p>矩阵乘法是一个非常好理解的模型，在我的设想中，由用户给出矩阵的规模$n$，接着由系统生成两个符合规模的方阵A和B，然后再由用户设置计算时的线程数，系统通过多线程计算将结果存入结果矩阵R，并记录每次计算的相关信息与耗时，且以合适的可视化方案反馈给用户。</p></blockquote><p>在学了个七七八八之后，我开始思考如何让这么多线程去合理地计算几百万个数据，从而得到由100多万个元素组成的结果矩阵，摆在我面前的有两种方案，一是加锁，或许更符合指导老师的本意；二是无锁，追求更好的性能。</p><p>由于深受线程同步理念的<del>毒害</del>，我决定给并行矩阵乘法加锁，每个线程每次计算一个元素，多个线程通过抢占的方式共同完成所有的计算任务，通过设置一个共享的<strong>自增计数器</strong>来判断计算过程是否结束。这看起来非常合理，是一个好办法，非常典型的多线程程序模型对吧，但是我发现一个可能因为我没有深入研究而没有解决的问题：当我将这个计算过程包装在一个循环中以便探寻在不同并发数下的耗时情况时，除了第一次外，其余轮次计算的耗时全部被“优化”成了0ms，我确信我的代码逻辑没有问题，那会不会是循环中的整个计算过程并没有那么完整？于是我将读取数据的方法也添加到循环体中，这一次很幸运，每一次的耗时都是通过真实运行计算出来的，但是每次计算都要从！文！件！去读数据，这是一件很恐怖的事情，对于<strong>1024×1024</strong>规模的矩阵，还是2个，光是读数据就要耗费七八秒的时间，这为了得到测试数据就要花几天时间，对于期望赶紧速通这个课设的我来说是万万不行的。</p><hr><p>于是一夜回到解放前，我着手开始考虑无锁方案，一个非常关键的事情是，在【<strong>将计算结果的一个元素作为一个子任务</strong>】这个前提下，如何安排这一百多万个子任务。这是一个严肃的问题，因为子任务的安排模式将直接决定每个线程需要执行的子任务数量，而其中背负子任务最多的那个苦逼线程就直接决定了本次计算的耗时，因此这个安排模式必须尽力保证每个线程分配到的子任务数量是均匀的，这样就可以保证<strong>最累的线程和最轻松的线程所计算的子任务只相差1</strong>，换句话说，不管并发线程数怎么变化，各线程执行的最大子任务数只比最小子任务数多1，而对于这个时代的CPU，计算矩阵乘法的一个元素只区区一个小case罢了。</p><p>因此，我的最终目标就是：比如说对于4×4规模的方阵，假设有7个线程并发计算矩阵乘法，那么每个线程计算的子任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">1</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">2</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">3</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">4</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">5</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] <br>Thread-<span class="hljs-number">6</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>这看起来真的很美妙，把所有的子任务都按列挨个儿分给所有线程，分完整列还剩下的就顺延到下一列，多么直观的逻辑，而它实现起来也是异常简单。</p><p>首先我们先定义一个表，我擅自将它命名为任务分配表，aka英文名TAT(Tasks Assignment Table)，TAT能够表达上面这个例子的含义，但形式上需要转变一下，后面会讲到。</p><p>光有这个表还不够，我们需要为所有的子任务编号，对于规模为$n×n$的矩阵，计算得到的结果矩阵规模也为$n×n$，包含$n^2$个元素，那么编号就从1到$n^2$，例如对于$4×4$规模的矩阵，编号就从1到16。</p><p>准备工作就到此结束，接下来开始表演。</p><p>首先需要确定TAT的规模，确保它能够保存所有的子任务序号，因此通过$n^2\ mod\ nThreads$，即任务数对线程数取余得到余数，如果余数是0，说明能够正好均分，否则说明需要对TAT增加一列存放剩余的子任务。</p><p>TAT的每一行的行号代表线程号，这一行中的元素代表本线程需要执行哪些任务，但是作为一个整型的二维数组，TAT很难表达出$[0][0]$这样的含义，于是我们可以借助刚刚的子任务编号构建一个映射，我称之为【子任务序号——TAT映射】，顾名思义，这是把子任务序号映射在TAT上的过程，这样就能够用数字来表示各元素的下标了。</p><p>整个过程需要两个循环来实现，当然它们之间事实上是存在数学关系的，能够用一次循环来实现，但数学总是不简单的，因此这里我们怎么简单怎么来。第一步循环是对需要映射的位置进行标记，第二轮循环通过按列遍历TAT来在相应位置上赋值，闲言少叙，直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">nTasks</span> <span class="hljs-operator">=</span> length * length;<br><br><span class="hljs-comment">// build tasksTable[][]</span><br><span class="hljs-type">int</span>[][] tasksTable;<br><br><span class="hljs-comment">// initialize tasksTable size</span><br><span class="hljs-keyword">if</span> (nTasks % nThreads == <span class="hljs-number">0</span>) &#123;<br>    tasksTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nThreads][nTasks / nThreads];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    tasksTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nThreads][nTasks / nThreads + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// load all tasks to tasksTable[][]</span><br><span class="hljs-comment">// 将所有子任务序号映射到任务分配表</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nTask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 设定子任务序号遍历初始值为1</span><br><span class="hljs-comment">// 按列遍历任务分配表中与子任务数量相同的元素数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tasksTable[<span class="hljs-number">0</span>].length; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasksTable.length; i++) &#123;<br>        <span class="hljs-comment">// 当子任务序号小于等于子任务数量时将当前元素置1</span><br>        <span class="hljs-keyword">if</span> (nTask &lt;= nTasks) &#123;<br>            tasksTable[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 进行置1操作</span><br>            nTask++; <span class="hljs-comment">// 子任务序号递增</span><br>        &#125;<br>    &#125;<br>&#125;<br>nTask = <span class="hljs-number">1</span>; <span class="hljs-comment">// 重置子任务序号遍历初始值为1</span><br><span class="hljs-comment">// 按行遍历任务分配表，对其中所有置1的元素赋值子任务序号</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tasksTable[<span class="hljs-number">0</span>].length; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasksTable.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tasksTable[i][j] == <span class="hljs-number">1</span>) &#123;<br>            tasksTable[i][j] = nTask;<br>            nTask++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>下一步操作是线程内部的运算过程。我们假设子任务的编号是按矩阵横向遍历顺序递增的，于是这个编号与矩阵的元素下标之间也是存在数学关系的，可以找出规律：</p><p>$$<br>i&#x3D;\lfloor\frac{nTask-1}{matrix.length}\rfloor<br>$$</p><p>$$<br>j&#x3D;(nTask-1)\ mod\ matrix.length<br>$$</p><p>这样就能根据编号$nTask$计算出要求的元素下标$matrix[i][j]$。</p><p>为了方便理解任务分配的过程，使子任务竖着排队无疑是最直观的方案，但性能却不是最高的，要解释这个问题需要了解一些底层知识。</p><p>首先，在编译器的眼中没有多维数组的概念，所有多维数组都被横向拉长成一行放在内存中，但由于数组元素可以通过下标直接访问，编译器会根据下标直接计算出数组元素的实际地址，因此访问数据元素的不同方式没有明显的性能差距。</p><p>接下来需要了解一下局部性原理：在现代计算机的存储体系中，存在多个寄存器以及多级高速缓存，CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。这时候联系一下上一条可以发现，如果现在CPU读取的元素是$[0][0]$，寄存器中很有可能缓存了$[0][1]$而不太可能缓存了$[1][0]$，因此，由于按列分配的模式会导致TAT的行元素之间相互割裂，局部性原理难以发挥作用。</p><p>但有意思的是，在上面代码的这种分配策略下，只需要互换28与29行就可以实现按行分配子任务了，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">1</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">2</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">3</span>: [<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">4</span>: [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">5</span>: [<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">6</span>: [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] <br></code></pre></td></tr></table></figure><p>如果你已经明白了上述的简单策略，那么恭喜你，你已经有了多线程编程的思想钢印，只要了解一下你喜欢的语言中多线程的语法，就可以尝试慢慢搭建整个项目了。</p><hr><p>为了要求的UI界面，必须要展示更多信息，展示更多信息就要写更多代码，况且UI线程占用系统资源的能力并不逊于多线程编程自身。虽然相较于写后端逻辑我更喜欢前端的那种表现力，但是我也对为这玩意儿开发UI感到厌恶。即便我在学习多线程的时候发现自己对多线程还比较感兴趣，但明明是关于底层设计的课设被改成提升应用层不说，更甚的是UI的加入彻底地将其变成了一个独立的应用程序，把这个课设的核心完全移出操作系统这个范围了，根本就不属于操作系统的项目。</p><p>我感兴趣的方向好像是两个极端，一是完全地与用户互动，二是彻底地与开发者交互。在我刚开始Hello World的时候，我首先想知道的就是怎么实现输入，因为实现了输入就意味着我可以控制程序运行的方向，这个程序的控制权在我的手中，慢慢地就不再仅仅乐于在命令行里折腾，想去实现真正的界面，那种灵动的布局、流畅的动效和严谨的适配，真是浪漫的美学与严肃的工程的完美结合，所以去做大前端，去用图形界面与屏幕前的你开展无声的交流，这是我能想到的代码与人类之间最友好的沟通方式。</p><p>对我来说，写多了代码很不幸地激发了我对“程序是怎样产生的”这样一个话题有了好奇，不过即便是在编译原理课上学习了词法分析&amp;语法分析&amp;一点点语义分析，没有写过一行相关代码的我也感受不到这就能把我写的代码变成一个 <code>.o</code>、<code>.class</code>或者 <code>.exe</code>，所以还是很好奇这个编译的过程。在无意间翻了几十篇网刊文章后算是找到了一些有关底层原理的系列文章，希望自己有时间去跟随这些牛人，在未来有这样的可能去为框架、工具链、编译器贡献一行自己的代码。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2022/01/10/2021-year-end-review/"/>
    <url>/2022/01/10/2021-year-end-review/</url>
    
    <content type="html"><![CDATA[<p>今年的春节来得比去年更早一些……</p><p>去年的跨年，我在浴室里诗意兴起，敲下一首小诗，现在看来倒是有几分艺术，因为<del>我也看不太明白了</del>。</p><span id="more"></span><hr /><p>一月已经悄悄走过了10来天，其实到现在再来回想整个2021，除了家里有一些意外让我几乎白活了一个暑假之外，别的地方都还好，那些不痛快的事情就选择性忘记它们吧。</p><p>这一年依然感到没有太多时间去认真学一学自己感兴趣的技术，专业选修课也不那么有意思，就是说理论基础没觉得有什么加强，代码能力也没什么提升，也就剩下<em>和成员们用</em>SpringBoot完成了课设<strong>小</strong>项目是一段挺好的经历，说它<strong>小</strong>是因为把项目架构和需求理过一遍后发现它确实不庞大，期间遇到的困难其实都是需求建模不完整的问题，这大概主要源于大家都没有项目开发的经验吧，哪怕自己接触过需求，对需求的认知也没有那么清晰，而真正技术上的问题其实都可以在网络上找到解决方案。经过了这一次课设，我也算是对一种计算机语言与其编写的框架之间的关系有了了解，知道了如何站在巨人的肩膀上眺望远方。</p><p>开始的开始，我是对<strong>写出怎样的程序会输出怎样的结果</strong>感兴趣，但随着时间的推移，我开始好奇<strong>写出的程序如何被转化为输出的结果</strong>，也就是所谓的编译过程，什么gcc、clang、javac、cpython/jpython、ChromeV8……我尝试搜索每一种编程语言，在百科中寻找它的编译器是用哪一种语言实现的，这给我一种非常奇妙的感觉，好像编译器/解释器就是软件工程的<strong>终极奥义</strong>，因为有了编译器，你仿佛可以创造整个<strong>Cyber</strong>世界。</p><p>因此我个人对编译原理有几分兴趣，奈何作为专业课我实在学不太明白，以至于如今课程结束了我还并不清楚学到的各种词法语法分析是如何理解程序代码的，可能课程开设的目的就是让学生浅尝一下编译过程吧，没什么大目标的。而本来我还想找一些编译原理的书或视频来看看，也没想到选修课的实验会比专业课还耗时，剩下一点碎片也没法干什么。</p><p>虽然跨年的夜晚本质上和其他任何一个普通的夜晚都没有什么区别，但是从形式上这是一个焕然一新的标识。随着期末周的结束，最疲惫的日子也终于过去，下学期也必然不会有那么多琐事了。</p><p>这一年下来，越是写程序，越是发现自己其实是一个感性的人，我的感性驱使着我，在我感兴趣的事情中做理性的人，反之，在不感兴趣的事情中我也很难理性起来。有时候有一些想法，让自己一下子很快乐很激动，不过过了两分钟就发现确实没有什么地方能让我分享我的想法，随即也就冷静下来该干嘛干嘛去了。不过这除了让自己慢慢变得不太会说话了之外也没有太多障碍，只是不太会有领导力了吧，也无所谓，反正我也不太愿意当强硬的领导。</p><p>……</p><p>勉勉强强算是过完了一年，我还记得自己在<ahref="https://skycurtain-dreamland.netlify.app/2021/09/19/0919-thinking/">0919：散谈|Skycurtain.Dreamland</a>中挖的坑，希望在完成之时它会是一个带点小惊艳的产品，让环境配置不再是非科班学生的噩梦，让编写代码不再是桌面端系统的专属。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot 初体验：为了课设</title>
    <link href="/2022/01/08/springboot-foretaste-for-course-design/"/>
    <url>/2022/01/08/springboot-foretaste-for-course-design/</url>
    
    <content type="html"><![CDATA[<p>这学期的数据库课程设计，在我一通安利之后，我们小组接受了使用前后端分离的架构模式。</p><span id="more"></span><hr /><p>对我来说，这是我从Java基础之后直接转向Web开发的一次体验，说来惭愧，大学生涯过半，这才是我第一次开发一个完整的项目，也是第一次将流行的现代化开发技术运用到实际的项目中。</p><p>其实按照JavaWeb技术栈的学习路径来说，我这种“不胫而走”的学习过程实在过于跳跃了，但是好在我有幸找到了还算不错的资料，这种“一步登天”并没有让我遇到很大的阻碍，在功能的需求确定之后，整个后端的搭建与开发过程还是比较顺利的，期间也新学了一些多方面的技术与工具的使用。</p><p>接下来我想叙述一下自己从创建新项目开始到最终写完接口文档过程中的几个<strong>关键点</strong>，以便给未来要构建新项目的自己一个参考与总结。</p><h2 id="从新建项目开始">从新建项目开始</h2><p>借助全宇宙第一的IDE ——<del>喷气大脑</del>JetBrains的IDEA，通过自带的SpringInitializer就能够十分轻松地创建SpringBoot项目了，不那么简单的其实是完全不清楚那一大堆依赖项都有什么作用，也不知道一个简单的项目首先需要用到哪些依赖。实话说，在私下经历了几次重开之后我才算琢磨明白要用到哪些依赖，也算是规划好项目的层次结构了。</p><h2 id="万物起源登陆">万物起源：登陆</h2><p>对所有的信息管理系统来说，登录功能几乎是这类软件功能的基石，所有的用户角色、权限，所有的实体功能都要建立在用户一登录的基础上。如果没有一套较为完整的登录流程，整个系统便无从运行。</p><p>在前几个学期，我做过一个要求不高的课设，那时候还没有要求设计UI，也没有任何数据库，只是简简单单地通过C++标准库的<code>fstream</code>把信息写进文件，想实现登录只需要做一个判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(username == input_name &amp;&amp; password == input_password)<span class="hljs-comment">// 判断用户名和密码是否匹配</span><br></code></pre></td></tr></table></figure><p>但是现在不一样，现在有数据库，每当前端传来用户名和密码，都需要通过用户名和密码向数据库查询是否存在该用户，同时考虑到用户离职，但是不能够简单地将其从数据库中删除，这样会影响到后续的的数据统计，因此需要另设置用户的“在职”识别码，说白了就是个<code>boolean</code>变量，进而通过判断该用户是否在职来确定是否允许该登录请求通过。而且通常情况下咱们登录一个网站后，这个登录状态其实是有期限的，过期后就需要重新登录，这说明我们需要一个地方来保存下每个登录用户的登录状态，这个登录状态包含了用户的非敏感的登录信息，并且这个登录状态必须是唯一的，以此来保证这个登录状态不会被重复利用。</p><p>这种场景有一个专门的名字：<strong>跨域身份验证</strong>。其中比较主流的方式是JWT，即JSONWebToken：在前端发起登录请求后，服务端会通过登录信息来构建一串token作为该用户本次登陆的唯一凭证，这个token会被前端保存下来，之后的每次请求中都会携带token，由服务端来校验token是否合法，进而决定是否要执行功能代码。而这个token会采用一定的认证算法将携带的信息载荷加密形成签名，一旦载荷被修改，签名则立即发生变化，这样服务端获取token后只需通过载荷与约定的认证方式来计算出签名进行比对即可。</p><p>具体到JWT的实现上，虽然自己从头写一个工具类不算困难，但事实上有许多细节是需要考虑的，而且一个成熟的工具类需要后续不间断的维护和更新，所以本着非必要不造轮子的原则，比较著名的JJWT和Java-JWT包都是不错的选择。在使用了JJWT后，我个人还是比较推荐Java-JWT，感觉它的限制会少一些，可以将token验证流程控制得更加精细。</p><h2 id="城门卫士拦截器">城门卫士：拦截器</h2><p>所谓拦截器，在这个小项目中最主要的作用是拦截所有登录之外的请求，只有用户登录情况正确后才能执行相应的功能。在SpringBoot中，SpringMVC已经为我们提供了拦截器，称为<code>HandlerInterceptor</code>，其下有三个方法声明，分别为<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>，分别用于在<code>Controller</code>方法执行前、<code>Controller</code>方法执行后而<code>ModelView</code>渲染前、<code>ModelView</code>渲染后。由于项目中只用到了<code>preHandle</code>，因此先简单介绍一下这个方法。</p><p>方法包含3个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpServletRequest request, HttpServletResponse response, Object handler<br></code></pre></td></tr></table></figure><p><code>request</code>是当前服务端收到的请求</p><p><code>response</code>是当前的响应</p><p><code>handler</code>可以认为是<code>Controller</code>方法的整个方法签名</p><p>接着描述一下拦截的逻辑：首先我们需要实现<code>HandlerInterceptor</code>类并重写<code>preHandle</code>方法，在方法体中，首先获取token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br></code></pre></td></tr></table></figure><p>去具体判断何时应当认为token是符合约定的，即什么条件下允许服务端执行用户请求的功能。</p><p>随后，需要针对新增的拦截器添加配置，这一点通过SpringBoot的配置类来实现，我们需要做的有：</p><ol type="1"><li><p>实现<code>WebMvcConfigurer</code>接口</p></li><li><p>重写<code>addInterceptors</code>方法</p></li><li><p>方法中添加配置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>   registry.addInterceptor(loginInterceptor)<br>         .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截路径</span><br>         .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 排除路径</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这样，拦截器便可以根据路径启用对应的拦截。</p><h2 id="和而不同跨域">和而不同：跨域</h2><p>什么是跨域？当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。而在我们的课设项目中，前端与后端的端口分别为8080和8888，因此当前端发出一个请求时，请求的url端口号是8888，而当前页面url的端口号则是8080，这就形成了跨域。</p><p>浏览器默认是不允许跨域的，这源于浏览器的同源策略。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><p>先不用关心如果没有同源策略的限制将会使前后端交互出现什么安全性问题，现在只需要知道同源策略能够在一定程度上规避一些危险，但却使开发人员需要额外考虑跨域问题，而跨域解决方案的执行对象则比较宽松，既可以由前端来做，也可以由后端来实现。而项目中前端的数据渲染是重中之重，因此就决定将所有看不见的部分都交给后端来考虑。</p><p>在SpringBoot中，由于它已经为我们定义好了相关的接口，因此我们需要做的有：</p><ol type="1"><li><p>实现<code>WebMvcConfigurer</code>接口</p></li><li><p>重写<code>addCorsMappings</code>方法</p></li><li><p>在方法中添加配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>        .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)<br>        .allowCredentials(<span class="hljs-literal">true</span>)<br>        .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>        .maxAge(<span class="hljs-number">3600</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="小插曲">小插曲</h3><p><strong>但是</strong>事实上，当我做完这一切以为只剩下前端负责的工作时，功能测试立马就出了问题：由于我没有前端来做真实测试，只好通过Postman来做请求测试后端功能，全无问题，然而但前端完成渲染后开始测试时却出现了接连不断的<code>500 error</code>，大家伙儿对着浏览器F12瞪了半天没看出来究竟是哪里的问题。很无奈，只能在百度上瞎猫碰上死耗子一般地搜索关键词，想不到还真能碰上记录了相同问题的文章，在这里感谢文章<ahref="https://www.cnblogs.com/penghq/p/13163779.html">springboot拦截器导致@CrossOrigin失效</a>。</p><p>其<strong>原因</strong>在于：CORS复杂请求时会首先发送一个<code>OPTIONS</code>请求做嗅探，来测试服务器是否支持本次请求，请求成功后才会发送真实的请求；而<code>OPTIONS</code>请求不会携带数据，导致这个请求被拦截了，直接返回了状态码，响应头中没携带解决跨域问题的头部信息，出现了跨域问题。</p><p>知道了原因，那么<strong>解决方法</strong>其实在非常简单，只需要在拦截器中首先检查请求的方法是否为<code>OPTIONS</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于配置了跨域，如果拦截的是预检的OPTIONS请求，则放行</span><br><span class="hljs-keyword">if</span> (request.getMethod().equalsIgnoreCase(<span class="hljs-string">&quot;OPTIONS&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h2 id="天下太平统一异常处理">天下太平：统一异常处理</h2><p>在前后端分类的项目中，前后端的通信就都是依靠请求和响应报文来实现，因为关于计算机网络底层的那些通信协议由操作系统和框架帮助我们搭好了脚手架，所以站在业务开发的角度，我们只需要考虑以怎样的统一格式来规范请求和响应报文。</p><p>在我们的项目中，对于请求体而言，由于SpringBoot提供的<code>@RequestBody</code>注解能够将JSON字符串封装为定义好的类，因此只需要针对一个或多个功能请求设计一个对应的实体请求类：</p><p>例如对于登录功能而言，请求体中必然包含<code>userID</code>以及<code>password</code>字段，因此就可以定义<code>LoginRequest</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginRequest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String userID;<br>    <span class="hljs-keyword">private</span> String password;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Controller</code>响应的方法参数中获取这个类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseResult&lt;Object&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginRequest loginRequest)</span> &#123;<br>        <span class="hljs-comment">// 从loginRequest中获取信息执行登录操作</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>而响应体则不像请求体那么多变，响应体可以抽象为具有统一格式的实体类，由<strong>响应码</strong>、<strong>消息</strong>、<strong>数据</strong>三部分组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseResult</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">// 响应码，类似与HTTP code，但能够传递更加明确的信息。</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">// 响应码代表的消息，前端可以通过响应码和提示消息共同判定用户请求是否存在异常，</span><br><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">// 由于要传输的数据类型会根据需要的不同而变化，因此采用泛型。</span><br><br>    <span class="hljs-comment">/* 包含部分参数的构造方法 */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>说了这么多，其实都是在为<strong>统一异常处理</strong>设下铺垫。我们时长能看到有时候网页提示各种错误，比如<code>404</code>、<code>500</code>、<code>502</code>……当然这些基本上都是后端的服务器本身出了问题，但是在实际的场景中，服务端代码抛出的异常并非都由系统异常引起，相反，大部分异常都是由<strong>不合理的请求</strong>或者<strong>错误的代码逻辑</strong>引起的，而这些异常如果直接返回给前端甚至用户，用户并不知道究竟是什么地方出了问题，本着<strong>自己的锅自己背</strong>的原则，统一异常处理就体现得很有必要而且格外优雅了。</p><p>在SpringBoot中，存在专门的异常处理机制，通过在类上添加<code>@ControllerAdvice</code>注解告诉Spring这是一个异常处理类，可以捕获项目中抛出的所有异常，在异常处理方法中，可以通过添加<code>@ExceptionHandler</code>注解来声明该方法用于处理哪种异常。</p><p>具体到课设项目，在拦截器中，如果token验证不通过，则会直接抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid Token&quot;</span>);<br></code></pre></td></tr></table></figure><p>在异常处理流程中，通过判断<strong>异常所携带的信息</strong>是否与<strong>所期望的信息</strong>相同来决定向前端返回怎样的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginControllerAdvice</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(RuntimeException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseResult&lt;Object&gt; <span class="hljs-title function_">loginControllerAdvice</span><span class="hljs-params">(RuntimeException e)</span> &#123;<br>        <span class="hljs-comment">// 获取异常信息，如果与约定的异常信息相等则认为是登录异常，返回响应体，否则直接返回异常信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> e.getMessage();<br>        <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;Invalid Token&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseResult</span>&lt;&gt;(<span class="hljs-number">10401</span>, <span class="hljs-string">&quot;Invalid Token&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseResult</span>&lt;&gt;(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交流共享接口文档">交流共享：接口文档</h2><p>写到这里，技术上想说的大部分都说完了，接口文档主要是为了方便前端开发，将所有接口的JSON规范以实例的形式展现出来，这样前端则只需要根据JSON格式来构造请求和渲染视图，而在测试出现问题时，前后端联调也更容易定位到bug所在的接口。在这一点上，开发过程中我是深有体会的，而事实上我写的接口数量要比实际上前端用到的要多，因此这份文档甚至在些报告的时候也帮助我确定了哪些接口没有用过，即不需要在报告中体现的部分。</p><h2 id="总结">总结</h2><p>以上便是Spring Boot给我留下的第一印象了，不愧是JavaWeb领域的头把交椅，更新的速度也是飞快。</p><p>当然，我这种“跳级”的学习方式是绝对不推荐的，要不是为了能够不用每次课设都挖新坑，我肯定更愿意去了解一下计算机语言本身的魅力，毕竟人们都说程序员的三大浪漫是<strong>编译原理、图形学和操作系统</strong>，这一学期算是一次性摸遍了这三个领域，操作系统对我而言没有太多感触，可能是因为我学得不认真吧，图形学用的是古老的GLUT图形库，说实话就是——没什么好说的，而编译器的魅力则是吸引我很久了，只是手造语法分析总是让我感觉不得要领。好了说回来，JavaWeb的学习路线还是有些坡度的，对于想走这JavaWeb这条路的初学者，我从一个同为初学者角度来说还是建议从HTTP、Servlet等基础开始学习，毕竟根基不牢易遭反噬不是吗？</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0919：随想</title>
    <link href="/2021/09/19/0919-thinking/"/>
    <url>/2021/09/19/0919-thinking/</url>
    
    <content type="html"><![CDATA[<p>——“我确实对那些高大上的技术没有很高涨的兴趣，唯独希望设计几个有影响力的小作品，或针对开发者，或针对在校学生。”</p><span id="more"></span><hr /><h2 id="x0000a000">0x0000A000</h2><p>——我想我永远不会忘记第一次在一个学编程的网站上成功运行<code>printf("Hello World!");</code>的那一刻，那时我切身地感到面前的电脑此刻才真真正正属于自己。</p><h3 id="x00">0x00</h3><p>这学期有一门听起来比较有意思的课程，<strong>关于企业开发</strong>，其实我蛮早就对这门课有所好奇，感觉能够学到一些实践性更强的技术，而不是像学校里一学期<code>C++</code>一学期 <code>Java</code>一学期<code>C#</code>还都只是学到面向对象。后来，加入了负责老师建立的课程群，了解到学校会请一些企业工程师或高管来做讲座，于是在暑假末期通过腾讯会议开办了2场讲座，然而在听过这2场的内容后，我却不太想开学了。第一场讲座，嘉宾是一位来自微软的工程师，毫无悬念地，这是一场持续3个小时的<code>.NET</code>框架和及相关介绍，我不知道这听几个小时有什么作用，我只知道B站有大把的<code>.NET</code>教程；第二场讲座，来者是一位证券公司的系统开发工程师，先不管是金融机构还是互联网公司，只要是系统开发，那讲的就是系统架构了，于是再一次毫无悬念地领教了信息管理系统的架构层级。</p><p>但开学终究还是来了，第三次的讲座内容几乎与代码层面的技术没有什么关系，看到了一位实现了财务自由的技术转金融的35岁投资人介绍<code>AI</code>如何进入宝马工厂的汽车生产过程，还探讨了一点大学生活。实话说，没有我看到一个不错的<code>JavaScript</code>教程时激动。</p><p>我不再期待第四场讲座了。</p><h3 id="x01">0x01</h3><p>写到这里，倒不是说我看不起这样的讲座，只是这些内容即便是对于被迫来到<code>CS</code>专业的学生来说，也是一些常常会在信息流中被浏览到的知识，或许知乎上随便逛逛就会看到今天<code>AI</code>技术又被运用在了什么产业，百度上搜一个关键词就有<code>CSDN</code>的讲解，微博热搜就有各类科技新闻，甚至关注的公众号也会推送一些前沿科技的现状。相较而言，这几场讲座的受众，应当是在计算机领域里比我们更加普通的人。至少，这种介绍性的内容并不合我的胃口。</p><p>私认为像这样的课程，既然被冠以“企业”二字，那就应该教一些企业开发的相关技术或讲述一些企业开发领域的要点：<code>Git</code>入门、设计模式、<code>WebApp</code>、<code>JavaEE</code>、敏捷开发、持续交付……如果我是负责老师，我想我会将这门课作为让学生统一接触企业的形式。我大约只会请5位左右的企业工程师，针对某一技术栈，比如前端工程化，比如<code>JavaEE</code>，比如小程序开发。我会请这几位工程师成立一个暂时的开发团队，自拟一个项目，接着做好项目架构与技术选型，先做一次以前期准备为主题的讲座，说明课程的任务和要求，然后带领学生以分组开发的形式来开展课程，每组负责一个功能模块，由一位工程师担任组长，以每周开组会的形式进行项目的推进。每位学生需要做好周报，对每周的开发做一个总结，而作为考核，在期末时每个小组需要撰写一份课设报告，描述小组所负责的模块与开发过程。</p><h3 id="x02">0x02</h3><p>诚然上述看法稍显出鄙夷，但我并非极其厌恶这类对“高能”技术的介绍。然而对于我这样一个并没有系统地接触过一场从零开发项目的过程的人来说，马上就研究人工智能这种高端技术实在是有些不切实际，因此我也并没有选择这学期的机器学习选修课，而退一步说，短短三个小时也难以厘清<code>.NET</code>的整条技术栈，何况至少目前我并不对<code>Windows</code>开发有很浓厚的兴趣。我更加喜欢那种技术性更强、实践性更好的课程，即便是纯理论，我也认为需要搭配上实操，只有当自己在真实的系统环境上操作过才能体会到理论是如何服务应用场景的。</p><p>正因为我深知现在的自己实在是没有什么开发经验，所以才不愿意马上就接触那些高层次的、面向未来的理论和应用，而是更希望去实际地学习几项企业开发的技能，作为一名预备程序员，代码能力应当是首要的，否则拿什么去支撑起自己的<code>ideas</code>呢？其余的那些设计思想或是算法，也都是以服务开发过程为目标的。仔细想想，如果学习这么多的理论，但是却没有足够的能力支持自己开发一个作品，做不出一个完整的项目，那是一件令人挫败的事情。</p><p>很不幸，我现在就是这样。</p><h2 id="x0000a001">0x0000A001</h2><p>——从那一行C语言代码开始，关于这些代码如何运行而变成一句“<code>Hello World</code>”这件事，我有着浓厚的兴趣，并且，对于我想开发的作品，我所拥有的一切幻想，也从这一行代码开始。</p><h3 id="x03">0x03</h3><p>尽管我支持<strong>用实践帮助学习理论</strong>的观点，但是在以往的几个学期里，有太多莫名其妙的实验课，当然并非是实验课本身没有存在的必要，而是必须要写的实验报告，用无趣又无情的格式要求消磨掉了很多时间。那些我可以用来学习兴趣所在的时间，都变成了抄写实验要求，变成了手抄实验代码，变成了胡编实验小结，变成了没有问题也要想出几个问题来写上去，这就是无意义的形式主义吧，不加限制就会发展为内卷，而我们又不得不加入内卷。然而在漩涡里两年了，我也没有卷死过什么人，但自己却是感受到了危机，真的，看起来学了很多知识，但是我不知道怎么开发一个项目，我不知道怎么实现我幻想中的产品，我好像有一个大致的思路，意思是我应该知道我想要的东西会长成什么样子，但是我不知道怎么去塑造它。</p><p>以前看过一篇教育文章，家长们很不理解为什么孩子会陷入游戏而不爱学习，“要是把你玩游戏的精力用到学习上你成绩早就上去了”，实际上从游戏和学习的本质来看，它们的核心相同点就是你需要靠一定的努力去获得一定的成果。游戏中可以升级，可以赚经验，可以赚金币银币，一场游戏下来所获得的成就就很可观，因此激励玩家快速投入下一场游戏，但是学习不一样，通过学习获得一定的成果，这个过程远比打游戏要漫长得多。试想，你玩的游戏在某个阶段升级需要几百万经验，而一场游戏赢了也不过只能获取最高一千出头的经验，在一个等级停留了几百场甚至千场，那种无力感肯定会让你肯定会想不通：“这游戏是认真的吗？！”当我在抄写实验指导书上的那些要求和大段的实验代码时，我就有这种无力感。我不是那种有能力搞内卷的人，我不愿意参加那些奇怪的学校活动，也不想参加什么专业无关的比赛，但是综测会参与到奖学金评选，我很容易被别人靠综测反杀，但是的但是，我真的想多琢磨琢磨我的fantasy。</p><p>暑假伊始时我给自己列了一份很现实的清单，记录了一些我想学的技能，但是不曾想暑假里发生了<strong>一连串我无法预知的事情</strong>，我知道，这一系列计划都不得不中断，意味着虽然我无需抱怨那该死的实验，但我依然有两个月时间无法集中精力做我该做的事情。假期中至少一半的时间里，我晚上都会出门溜达，我不喝酒，所以买瓶盐汽水，碳酸刺激口腔与喉咙的感觉才将我拉回现实中，那是我不可多得的清静时光。</p><p>毫无疑问，到开学时我的危机感更重了。</p><h3 id="x04">0x04</h3><p>新一学期终究还是到来了，我面临的是更重要的专业课，以及不那么有趣的选修课，还有一些课程设计和值得参加的比赛，是的，我终于明白自己应该去参加一些比赛。那些已经板上钉钉的事情我是没什么办法去改变的，有些无意义的东西我也不再想去做了，专注于我感兴趣的事情去做吧。我一直觉得学开发做开发就像玩游戏一样是一件见效很快的事情，甚至比打游戏获益的效率更高：写真真实实的代码，实现真真实实的功能。</p><p>前几天，朋友给我发了一串聊天截图，对方是今年保研资格的学长，有竞赛，有软著，有科研……对于保研，我可能深知自己几斤几两，但是那份软著却真正拨动了我心中的某一根弦，就像开头说的一样，我希望开发出几个有意思的、有实际意义的作品，对开发者或者大学生有用的应用。也许我会将其统统开源，如果能在自己的开源代码上成立商业项目，说不定我就能以此创业，当然做个打工人也没什么不好的，只是我应该会保留有这一份心，支撑我现在的学习。</p><p>雷军和尤雨溪一直是我愿意看向的人。</p><h2 id="x0000a002">0x0000A002</h2><p>——但愿我有时间去慢慢填补我挖给自己的坑，堆成一座山，蓄起一条河，养好一方人。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年终总结</title>
    <link href="/2021/01/25/2020-year-end-review/"/>
    <url>/2021/01/25/2020-year-end-review/</url>
    
    <content type="html"><![CDATA[<p>旧岁即去，年关将至，对于一个<del>新来的</del>博客人来说，总觉得要写点什么来让这一年在自己的脑海中留下一些印象。</p><span id="more"></span><hr /><h2 id="x00">0x00</h2><p>因为在去年暑假期间才稍稍规划了一下，决定开始逐步构建博客的内容。而做出这个决定时已经到了下半年，于是随着下半年的顺利开学，整个博客也因为学业繁忙而不能再更新，就连使用的框架都已经更迭了很多个版本。如今放假没几天，重装了系统的我基本安装好了需要的环境，生活也逐渐有了节奏，于是思考着将博客整体翻修一遍吧，翻修的过程其实比较枯燥，无非就是跟着文档一点一点改图标、背景、文字、标识，没什么好写的，而真正的重点在于——我觉得现在应该写点什么。因为别的日程还需要一两天来规划，而无论从期末还是年末的角度来说，这都是一个有意义的时间段。我想，既然别的大佬们都会在每年末做一个年终总结，那我也来“装模作样”地总结一下属于我的2020。</p><h2 id="x01">0x01</h2><p>焦虑。</p><p>整个2020上半年，可以说我都是有些焦虑的。这种焦虑比较特别，不是说我在焦虑什么，而是我不知道在焦虑什么，疫情的蔓延会让我焦虑，有些无厘头的课会让我焦虑，催命般的每日上报体温会让我焦虑……虽说都不是什么严重的大事，但每天都要一个接一个地遇到这些事儿就是会很不爽，比每天满课更感压抑，尤其是许多非专业相关的课，又不想上，又不敢不签到，真是糟心。</p><h2 id="x02">0x02</h2><p>痴呆。</p><p>倒不是说我脑子不正常，而是发现这种人情世故的变化一下子好快，有人分开，有人牵手，对此我其实并没有什么想法，但是在看到有小俩口儿一起去旅游时，我脑子里仿佛有什么东西一下子突破了，原来我们早就到了自由恋爱的年纪，再也没有刑法之外的顾忌，好像就是在一瞬间，我想通了这一点，然后只觉我好痴呆，“小丑竟是我自己”。但这样一个念头确让我想通许多，往大了说，在世界各地的同学朋友们都有太多的可能，未来都有太多的变数，有大佬写歌，有大佬做AI，有大佬玩特技……好像只有我上课之外什么支线活动都没有了，为了一个小小的梦想还要储备太多太多的基础。</p><h2 id="x03">0x03</h2><p>时间终于来到了下半年，整个暑假可算是能够让我好好放松一下，也有了构建这个博客的想法，不过因为想法产生得比较晚，所以直到八月中旬才有了两条内容。而很快又正常开学了，这学期中技术型的东西并不多，学的不是数学物理这样的理论就是一些基础的编程语法和思想皮毛，专业课上障碍不算大，倒是那些理论基础课都挺难的，时间也就都花在了这些基础课上，自然而然的也就没什么时间去进一步学专业相关的内容，博客也是刚刚起步就中断了更新。这一学期总体来说我只觉得不习惯，在所有的方面都感觉到不习惯。一方面可能是在家里确实待久了，一方面是繁杂的课实在太多了，利用一样工具完成作业的同时要学习这样工具该如何去使用，也只有在那两堂编程实验课上我觉得稍稍得心应手一些。完成作业与搞懂这些结论的确让我感受到真真实实的压力，以至于到了期末我只觉得像久病撒手一般的解脱，终于可以肆无忌惮地放任自己的懒惰。</p><p>自九月开学，就特别盼望国庆假期，仿佛那是德爷在丛林中的草原上搭建的shelter，是个避难的地儿，我能够闭上眼回味一下自己，再把某天摔碎的手机去送修，然后并不是像德爷一样最后重返文明世界，而是又被甩进大海继续漂流。</p><h2 id="x04">0x04</h2><p>年终了，也意味着新一年的即将开始，又到了一年一度的 <del>画饼</del>做规划的日子，于是趁着寒假的头上把出了两个月毛病的电脑重装了一下，还有各种app和软件依赖也基本安装到位了，也算是某种程度上的“以崭新的面貌面对新的一年”吧。</p><p>事实上我还没有画什么饼，而且我认为我也画不出什么大饼。我一直觉得自己不是那种擅长做很清晰的规划的人，顶多就是这两天我该干什么，或者是在一段时间里有一个很模糊的目标，可能这就是期末那几天我活得如此狼狈的原因吧，不过好在狼狈到底还是起了一点作用，也不算枉费几个晚上吧。但说真的我是不愿意再这么整了，况且也不是什么好方法，是该整顿一下自己了。</p><p>打字的这几个晚上，世界上有许多事情发生，疫情也有所反复，记得在年末的时候大家都在期望2021能好过一些，但目前来看，2020的余孽还没有消散，2021的美好距离我们还有一些距离。</p><h2 id="x05">0x05</h2><p>over！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于PowerShell跑不了Nodejs脚本的解决方法</title>
    <link href="/2021/01/23/solve-Powershell-cannot-run-Nodejs/"/>
    <url>/2021/01/23/solve-Powershell-cannot-run-Nodejs/</url>
    
    <content type="html"><![CDATA[<p>“因为在此系统中禁止执行此脚本。”</p><span id="more"></span><hr /><p>解决方法：</p><p>以管理员身份运行 <code>powershell</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">set-ExecutionPolicy</span> <span class="hljs-string">RemoteSigned</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Y</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在看完小米十周年发布会后</title>
    <link href="/2020/08/12/after-xiaomi-10-year-release-conference/"/>
    <url>/2020/08/12/after-xiaomi-10-year-release-conference/</url>
    
    <content type="html"><![CDATA[<p>——“等待下一个技术BigBang的时机”</p><span id="more"></span><hr /><p>作为一个科技数码产品爱好者，在看了几年的各种手机电脑评测、经历了一次又一次心动感动和不为所动之后，认清了每一款旗舰产品在其发布的那个时代里都不是百分百完美的，甚至相较于其发布前的一段时间也是不够完美的。</p><p>而如今电子产品更新换代速度越来越快，性能提升也不再惊人，将这种/发布会带来的重磅/与/很短时间后新产品带来的变革/之间的落差/对购买欲造成的忐忑/扩大了不少，即对下一代产品的期待降低了对这一代产品的购买欲，所以我曾经梦想着自己有朝一日能够有机会使用每一款我感兴趣的设备，而不用担心自己有没有钱买，或者，进入自己喜欢的产品所属的公司和企业来实现我的梦想。</p><p>在那时，我是个绝对的参数党，对于软件方面没有很多看法，只要硬件参数够顶就可以为它买单，但随着年龄的增长，手机电脑的应用场景越来越多，我认识到单纯的硬件不能够代表设备的使用体验，在旗舰级别的硬件参数基础上，软件环境更是重中之重，硬件的强大能力需要软件来发挥，高质量的软件环境才能配得上高水平的硬件参数。</p><p>产生这样的心性变化，我想，这大概就是现在我对于软件和系统上的折腾的兴趣要大过整天看手机电脑配置的原因吧，买硬件就像为了装备充钱，做软件就像为了排名练游，游戏实力的提升带来的感受是远比充钱更快乐的，即能力的提升是比外在的满足更充实自我的。买高配电脑，要配得上你对算力的需求，买旗舰手机，要配得上你对使用场景的理解，而这些需求和理解的基础，是你有绝对的实力说服自己购入心仪的产品，说到底还是对自我的提升。</p><p>今年是一个世界变革的节点，对于电子产品来说，也是技术革新的一个节点，我应该会多多专于自己的技术栈，也拾起对硬件的关注，耐心等待下一个技术BigBang的最佳时机。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是如何创建并部署我的hexo blog到gitee</title>
    <link href="/2020/08/09/how-I-build-my-hexo-to-gitee/"/>
    <url>/2020/08/09/how-I-build-my-hexo-to-gitee/</url>
    
    <content type="html"><![CDATA[<p>Blog初开，作为第一篇文章，我想记录一下自己从创建到部署它的全过程，也算是几天试验成果的一个总结。</p><span id="more"></span><hr /><p>一开始因为听说<code>Hugo</code>框架简单得离谱，于是作为一个菜鸡，我就愉快地按照B站找来的教程成功搭建了一个，随后在想为安装的主题添加更多自定义内容时，发现<code>Hugo</code>主题的文档都不够全面，更像是这些开发者做出来展示自己的，而且主题也都不太符合我的审美，遂弃之。</p><p>当晚决定用 <code>hexo</code>来完成这件事情。吃一堑长一智，这次先去<code>github</code>上找了一大堆主题，其中发现一个名为<code>fluid</code>的由国内开发者开发的主题，外观很不错，文档也很全面完整，就决定是它了！</p><hr /><h2 id="安装所需环境windows">安装所需环境（Windows ）</h2><h3 id="安装-node.js">安装 <code>Node.js</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://nodejs.org/zh-cn<br></code></pre></td></tr></table></figure><h3 id="安装-git">安装 <code>Git</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://git-scm.com/download/win<br></code></pre></td></tr></table></figure><h3 id="打开-powershell安装-hexo-cli工具包">打开<code>Powershell</code>，安装 <code>hexo-cli</code>工具包</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><hr /><h2 id="建立本地博客站点">建立本地博客站点</h2><h3 id="我想把博客项目文件夹放在桌面">我想把博客项目文件夹放在桌面</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> desktop/<br></code></pre></td></tr></table></figure><h3 id="建立本地站点我将其命名为-myblog">建立本地站点，我将其命名为<code>myblog</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure><h3 id="启动博客查看初始化情况">启动博客查看初始化情况</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo server<br></code></pre></td></tr></table></figure><h3 id="至此可以看到提示">至此，可以看到提示</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">INFO  Hexo is running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器打开 <code>http://localhost:4000</code>，可以看到<code>hexo</code>建站的同时有一个默认主题。</p><hr /><h2 id="更改配置-hexo主题">更改&amp;配置 <code>hexo</code>主题</h2><h3 id="检查是否在-myblog目录下">检查是否在<code>myblog</code>目录下</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h3 id="下载-最新-release-版本解压到-themes目录下并重命名为-fluid">下载<a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新release 版本</a>，解压到 <code>themes</code>目录下并重命名为<code>fluid</code>。</h3><h3 id="修改博客目录下的-_config.yml">修改博客目录下的<code>_config.yml</code>：</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">title:</span> <span class="hljs-string">Skycurtain&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Skycurtain</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="添加关于页">添加关于页</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo new page about<br></code></pre></td></tr></table></figure><h3 id="修改-sourceaboutindex.md在头部添加-layout-属性">修改<code>/source/about/index.md</code>，在头部添加 <code>layout</code>属性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br></code></pre></td></tr></table></figure><p>暂时就做这些处理，更多文档详见：https://hexo.fluid-dev.com/docs/guide/</p><hr /><h2 id="撰写第一篇文章">撰写第一篇文章</h2><h3 id="新建一篇post">新建一篇post</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo new post <span class="hljs-string">&quot;我是如何创建并部署我的hexo blog到gitee&quot;</span><br></code></pre></td></tr></table></figure><p>这样在source/_post/下会新建“我是如何创建并部署我的hexoblog到gitee”的md文件</p><hr /><h2 id="部署">部署</h2><p>首先需要在 <code>gitee</code>新建仓库</p><h3 id="修改-_config.yml配置">修改 <code>_config.yml</code>配置</h3><p>选择 <code>gitee</code>的原因是<code>Github Pages</code>的访问速度并不理想，而且暂时也没有考虑各种加速手段，所以尽管<code>gitee</code>有各种不足，但它仍然成为了我的选择。</p><p>鉴于 <code>Github Pages</code>的后端采用<code>Jekyll</code>，或许以后等我的博客成熟了会考虑迁移到<code>Jekyll</code>并部署到 <code>Github Pages</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://gitee.com/skycurtain/skycurtain</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h3 id="git配置">Git配置</h3><p>用 <code>VS Code</code>打开博客项目并开启终端（确保操作目录是<code>myblog/</code>）</p><p>配置git信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;Skycurtain&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email skycurtain@<span class="hljs-number">163</span>.com<br></code></pre></td></tr></table></figure><p>建立git仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git init<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git">安装 <code>hexo-deployer-git</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install hexo<span class="hljs-literal">-deployer-git</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件">生成静态文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo generate<br></code></pre></td></tr></table></figure><h3 id="一键部署">一键部署</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo deploy<br></code></pre></td></tr></table></figure><p>以上两步操作可以简化为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo generate <span class="hljs-literal">--deploy</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo g <span class="hljs-literal">-d</span><br></code></pre></td></tr></table></figure><p>最后在 <code>gitee</code>仓库的服务中选择<code>Gitee Pages</code>，选择 <code>启动</code>/<code>更新</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>关于</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
