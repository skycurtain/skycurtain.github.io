<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Arduino仿真の痛</title>
    <link href="/2022/11/29/arduino-simulation-and-serial-port-communication/"/>
    <url>/2022/11/29/arduino-simulation-and-serial-port-communication/</url>
    
    <content type="html"><![CDATA[<p><del>不要心血来潮做硬件仿真，会变得不幸。</del></p><span id="more"></span><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你学的不是软工而是计算机，那么你的遇到大作业可以变得多种多样！</p><p>我在开学前看这个硬件课设的大纲时，里面有一些软硬结合的项目，看上去都是以软件系统的形式作为最终呈现，所以我一个软件人早早地就看准了大纲中的一个偏软件的选题，但是新冠疫情完美诠释了什么叫做『天不遂人愿』——像上半年的操作系统课设一样——题目又被改了：4个Arduino编程，1个纯软件编码查看器，还有一个明确了不给高分的加法器模拟，直接把家里蹲的我从万事俱备整成不知所措，不过想到队友都在校，主动权必然是队友掌握，我也就不管选什么题了。</p><p>不得不说队友真是非常amazing啊，过了几天领到Arduino UNO开发板直接开始研究，两天之后硬件功能已经实现了，我当然不好意思腆着脸坐等项目完成，想着能否参与一下软件功能的实现，想不到有个大坑正等着我。</p><h2 id="仿真环境搭建"><a href="#仿真环境搭建" class="headerlink" title="仿真环境搭建"></a>仿真环境搭建</h2><ol><li>我们需要下载安装Proteus和Arduino IDE。</li><li>然后根据网上收集到的一些教程<sup>[1]</sup><sup>[2]</sup><sup>[3]</sup>逐步搭建仿真环境。</li></ol><p><img src="/./img/20221129/ArdSim.png"></p><p style = "font-size: 1.382rem; font-weight: bold;">坑：</p><p>问题出在测试虚拟串口连接时，无论如何都搜不到两个串口，自然也无法看到串口助手中显示出信息了。</p><p>一开始我还以为是代码的问题或者是配置的问题，但不管怎么尝试就是读不到串口，就差重启电脑了。</p><p><strong>巧了。</strong></p><p>搜到一个VMware的串口问题<sup>[4]</sup>，里面说虚拟机不支持热插拔，要<strong>重启电脑</strong>，事到如今也顾不得浏览器开着几十个窗口了，反正之后可以恢复，重启就重启吧。然后</p><p><strong>好了。</strong></p><p><strong>可以读到串口了。</strong></p><p><strong>挺好。</strong></p><p>随后根据课设的要求模拟了测试体温的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;LiquidCrystal.h&gt;</span></span><br><br>LiquidCrystal <span class="hljs-title function_">lcd</span><span class="hljs-params">(<span class="hljs-number">13</span>, <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>)</span>; <span class="hljs-comment">// 根据电路连接情况设置</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>  Serial.begin(<span class="hljs-number">9600</span>);<br>  lcd.begin(<span class="hljs-number">16</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">long</span> rand = random(<span class="hljs-number">359</span>, <span class="hljs-number">420</span>);<br>  <span class="hljs-type">float</span> output = rand / <span class="hljs-number">10.0</span>;<br>  lcd.setCursor(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  lcd.println(output);<br>  Serial.println(output);<br>  delay(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="软件与串口通信"><a href="#软件与串口通信" class="headerlink" title="软件与串口通信"></a>软件与串口通信</h2><p>秉持着『非必要不学新语言』的一贯原则，C#上位机必然不是我的首选，机缘巧合下发现了Node.js下有一个SerialPort<sup>[5]</sup>，加之我正好在学前端，遂大喜，这样就可以基于Node.js搭建一个简陋的前后端来提供友好的交互。</p><p>SerialPort的文档写得其实一般，所以在借助另寻的文档<sup>[6]</sup>后比较顺利地写了一个能够读取串口数据并进行判断体温的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.mjs</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">SerialPort</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;serialport&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; log &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;console&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERIAL_PATH</span> = <span class="hljs-string">&#x27;COM2&#x27;</span>; <span class="hljs-comment">// 端口号</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TEMPERATURE_THRESHOLD</span> = <span class="hljs-number">37.3</span>; <span class="hljs-comment">// 体温阈值</span><br><br><span class="hljs-keyword">const</span> serialPort = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerialPort</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-variable constant_">SERIAL_PATH</span>,<br>    <span class="hljs-attr">baudRate</span>: <span class="hljs-number">9600</span>, <span class="hljs-comment">// 波特率</span><br>    <span class="hljs-attr">autoOpen</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br><br><span class="hljs-comment">// serialPort.write(&#x27;Hello Arduino!&#x27;);</span><br><br><span class="hljs-keyword">let</span> serialInputList = [];<br>serialPort.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;readable&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> serialInput = serialPort.<span class="hljs-title function_">read</span>();<br><br>    <span class="hljs-keyword">if</span> (serialInput.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>) !== <span class="hljs-string">&#x27;0a&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (serialInput.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>) !== <span class="hljs-string">&#x27;0d&#x27;</span>) &#123;<br>            serialInputList.<span class="hljs-title function_">push</span>(serialInput);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> serialBuffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(serialInputList);<br>        <span class="hljs-keyword">let</span> temperature = <span class="hljs-built_in">parseFloat</span>(serialBuffer.<span class="hljs-title function_">toString</span>());<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTemperatureSafe</span>(temperature)) &#123;<br>            <span class="hljs-title function_">log</span>(temperature.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;°C&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\t\t&#x27;</span>, temperature.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">1</span>), <span class="hljs-string">&#x27;°C, WARNING!&#x27;</span>);<br>        &#125;<br><br>        serialInputList = [];<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// =====================================================================</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isTemperatureSafe</span>(<span class="hljs-params">temperature</span>) &#123;<br>    <span class="hljs-keyword">if</span> (temperature &lt;= <span class="hljs-variable constant_">TEMPERATURE_THRESHOLD</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>串口发送来的数据被Node.js接收后实际上是十六进制的Buffer类型，而在每一行数据的的行尾也都包含了换行符“0A 0D”，所以在读取数据的过程中需要对Buffer收到的每一位数据都做好检查。</p><p><img src="/./img/20221129/RunResult.png"></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1].<a href="https://www.theengineeringprojects.com/2021/03/arduino-uno-library-for-proteus-v2.html">Arduino UNO Library for Proteus V2.0</a></p><p>[2].<a href="https://www.bilibili.com/video/av840423815/">【教程】Proteus仿真Arduino，串口打印hello</a></p><p>[3].<a href="https://cloud.tencent.com/developer/news/163066">Arduino与Protues串口通信</a></p><p>[4].<a href="https://blog.csdn.net/readnap/article/details/116659657">vmware虚拟机检测不到vspd虚拟串口问题</a></p><p>[5].<a href="https://serialport.io/docs/guide-usage">SerialPort Usage</a></p><p>[6].<a href="https://www.v5w.com/js/js%e7%9f%a5%e8%af%86%e7%82%b9/429.html">JS知识点归纳 : serialport.js串口使用</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node.js</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈原型继承和类继承</title>
    <link href="/2022/09/21/prototypal-inheritance-and-classical-inheritance/"/>
    <url>/2022/09/21/prototypal-inheritance-and-classical-inheritance/</url>
    
    <content type="html"><![CDATA[<p>在学习了Java后，我自认为对面向对象编程有所了解，但当我开始探索JavaScript，我领悟到全新的<strong>『计算机艺术大师们的设计思想』</strong>。</p><span id="more"></span><hr><p><span style = "font-size: 1.5rem;"><strong>继承</strong></span>，这是面向对象编程(OOP)的三大核心思想之一，而将OOP思想严格而规范地体现在语法中的编程语言，在我为数不多有所接触的几门语言中，当属Java拔得头筹。这种<code>class entends class</code>的模式非常符合人们对生产生活需求的建模，尽管对于当时粗浅地学了一下C语言的我来说很难一下子去理解这种思想的优势，等到实际写过了不少代码后，接触到了一些需求，我才算是悟到了这种思想的精髓所在，以至于如今我看到一个需求时会下意识用Java的设计理念去思考，而从面向过程的角度来建模则觉得有些困难了。所以我在学习JavaScript的面向对象时，下意识地也将其与Java类比，但却不曾意识到JavaScript的所谓<strong>原型继承</strong>对我来说是一个全新的概念，与Java所代表的<strong>类继承</strong>共同打下了编程语言设计关于代码复用的一座江山（另一座是组合），是两派计算机科学家不同设计理念的杰作。</p><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>与地球生物数亿年来的演化相似，<strong>『类』</strong>这个概念也是编程语言几十年的发展过程中逐渐形成的。那些教程总是说“类是对象的模板，对象是类的实例”，到底什么是模板和实例呢？</p><p>最初的编程语言，大概只提供一些基本的变量声明和赋值、流程控制、函数等等，很快人们发现很多数据其实存在内在的关联，比如一个长方形有它的宽高，所以后来程序语言有了<strong>结构体</strong>这种东西，可以将宽高定义到一个长方形结构体里。</p><p>但人们逐渐发现一些函数也是与这个结构体有关的，比如可以对这个长方体求周长或面积，所以可以把这些函数与这个结构体封装在一起，结构体中包含了数据，函数描述了行为，这种数据和行为的封装被称为<strong>对象</strong>。</p><p>而为了能够便于多次创建同一类对象，<strong>类</strong>被设计了出来，将对象内部的数据属性和行为抽离出来合到一起，这就成为了一个<strong>模板</strong>，由这个模板产生的对象就是<strong>实例</strong>。</p><p>随着时间的推移，人们又发现一些不同的类之间也存在关系，并且是一种从属关系，比如说不管长方形三角形他们都是形状，不论是设计师还是程序员他们都是员工，老师和学生都是人，他们各有一些共性，如果把这些共性提取出来，就可以构成一些基础类，那就又可以提高复用能力了，事实上在不断的实践中人们也确实发现那些越是抽象和宽泛的类，其中的方法与有可能被复用，于是这种<strong>基于类的继承思想</strong>逐渐成型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> weight;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String name, <span class="hljs-type">double</span> height, <span class="hljs-type">double</span> weight)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.height = height;<br>        <span class="hljs-built_in">this</span>.weight = weight;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// walk</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// dog walk</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// cat walk</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><pre><code class=" mermaid">flowchart LR;class1[&quot;class&quot;] --&gt; class2[&quot;class&quot;];</code></pre><p>所以说类与对象之间的关系就好比产线与产品的关系，方法和数据的描述通常在类中定义，而数据的值则通常在实例中赋予，所以可以说<strong>基于类的继承实际上继承了数据的结构与模板的方法，而没有继承数据</strong>，但接下来要说的原型继承则能够连数据也一并继承。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>在类继承中，对象的模板是类，而在原型继承中，对象的模板是原型。其实我觉得在面向对象思想的术语中，<strong>“原型”</strong>这个名字相较于<strong>“类”</strong>更加直观，原型更加贴近模板的含义，像是原型车、原型机，代表一种范式，而由这种范式则可以衍生出各式各样的特例。</p><p>那么，<strong>原型</strong>是什么？</p><p>首先，原型，也就是prototype，它的工作是<strong>给其他对象提供共享属性</strong>。</p><p>对于函数而言，原型是一个属性。在JavaScript中，每个函数都有一个<code>prototype</code>属性，这个原型属性指向一个对象，这个对象称为<strong>原型对象</strong>。对于这个原型对象，不仅是函数的原型属性指向它，每个对象都有一个<code>[[Prototype]]</code>属性，这个属性也指向原型对象。</p><blockquote><p>但实际上很多时候我们并不严格区分原型、<code>prototype</code>、<code>[[Prototype]]</code>，原型属性、原型对象，而是统称为原型。</p></blockquote><p>当我们谈论的“原型”是原型对象时，事情离<strong>“继承”</strong>这个概念就近了一步。刚刚提到，每个对象都有一个<code>[[Prototype]]</code>属性，这个属性指向原型对象，而这个原型对象作为一个对象，它也有自己的原型对象，如此套娃就形成了一条<strong>原型链</strong>。</p><pre><code class=" mermaid">flowchart LR;object1[&quot;object&quot;] --&gt; object2[&quot;object&quot;];</code></pre><p>所以与类继承不同，原型继承中继承的并非类，而是对象，这就使原型继承拥有了<strong>继承数据</strong>的能力，所以有开发者认为能够继承对象的原型继承是比类继承更加面向对象的。</p><p>同时这也解释了当通过构造函数来实现继承时为什么会写出<code>child.__proto__ = parentFunction.prototype</code>或<code>Object.setPrototypeOf(child, parentFunction.prototype)</code> —— 把父对象构造函数的<code>prototype</code>赋值给子对象的<code>[[Prototype]]</code>，因为对于构造函数而言，它的<code>prototype</code>属性指向它的原型对象，所以只有当子对象的原型属性指向这个对象时，这个原型继承链才完美形成。</p><h2 id="JavaScript中的继承"><a href="#JavaScript中的继承" class="headerlink" title="JavaScript中的继承"></a>JavaScript中的继承</h2><p>现代JavaScript中也存在类的概念，不过JavaScript正统采用的是原型继承的思想，而类的概念是在ES2015实现的。</p><p>但是JavaScript中的类底层也是通过原型来模拟的，甚至为了让类看起来更像样，原型继承数据的能力被无情屏蔽了，这就是作为Java开发者在学习原型链时感到不得要领而学习类时则轻车熟路的原因了，无论在类中还是在类的构造函数中声明数据，它们都一律会出现在<code>new</code>出来的实例对象上，而非原型对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg">深入理解 JavaScript 原型</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你的下一台开发设备，何必是电脑</title>
    <link href="/2022/09/15/mobile-programming-thinking/"/>
    <url>/2022/09/15/mobile-programming-thinking/</url>
    
    <content type="html"><![CDATA[<p>自从我学会了<code>printf(&quot;Hello World!&quot;);</code>，就认为用来编程的设备可以不一定是电脑，因为我的第一行代码事实上就是在手机上写下的。</p><span id="more"></span><hr><p>今天看了关注的一个UP主的新视频<a href="https://www.bilibili.com/video/BV1FP411G7p8">【亦】M1让iPad取代电脑？让子弹再飞一会儿！</a>，其中谈有关iPad产品本身的内容我并没有太多的感受，毕竟我并不是Apple产品用户，但是视频有大段篇幅在聊iPad作为一款介于手机和电脑之间的产品，你可以说它不如手机便携也不如电脑强大，而我也可以说它“比手机更能干，比电脑更亲切”。</p><p>UP主自述上大学时第一次安装Visual Studio，打开后认为<strong>这根本不是一个未曾接触过编程的大一学生的心灵能够承受的东西</strong>。暂且抛开 VC++ &#x2F; DevC++ &#x2F; CodeBlocks 这类活跃在过时的课堂和存在限制的算法竞赛中的开发环境不谈，在集成开发环境(IDE)发展到了几年后的今天，被几大巨头垄断的主流市场也依然如此，各类功能强大的IDE都直接面向专业人士，致使初学者上手门槛较高。事实上IDE对我来说也只有一些常用的功能和快捷键是熟悉的，很多更加强大的功能却不是我常用的，在我决定学习前端后也仍是如此，VSCode配合强大的插件已经能够胜任几乎所有的前端开发要求，但即便作为一个基于代码编辑器的可扩展开发环境，VSCode依然有大量专业的设置项，我对它的使用依然不能称得上“熟悉”，所以事到如今，PC开发生态依然是专业向的，也正像视频中说的那样，在编程领域确实可以存在一个“比手机能干，比电脑亲切”的空间，而iPad的Swift Playgrounds就提供了这样一个空间，面向孩子或初学者，它把编程教学做成了小游戏，而面向开发者，虽然它比不上PC环境的专业性，但是能够让开发者快速实现小点子，并且能够迁移至Xcode进行更深入的开发。更让我感慨的是视频后段提到，在今年的移动应用创新赛中，超半数的参赛者都并不是开发者，这说明非专业人士也有涉足专业能力的机会和踏板，去实现他们脑海中那些站在科技与人文交叉点的想法。</p><blockquote><p>不过吧，对我个人来说，Apple的产品我并不很有兴趣，一是因为个人的使用习惯，二是因为我对生态开放的偏执。众所周知Apple的生态闭环收获了用户的大量好评，但对我来说，我思考过未来如果成为一个iOS开发者，我首先需要一台Mac才能够进行开发，而且也必须上架到App Store或者TestFlight，让我觉得不自由的也正是这一点，甚至，注册Apple开发者是要交钱认证的。相比之下，Android开发没有任何限制，我发送一个apk，对方的Android手机收到了就可以立即安装，虽说一旦我发送了恶意应用那对方安装了就会中招，不过我觉得这是安全教育应该要做的事情，其实即使是苹果生态中也存在不少不健康的应用，而我从一个开发者的角度，是比较偏爱这种『开发者能够直接将App交到用户手中』的模式的，而不需要一个应用商店这样的平台来控制我的行为。</p></blockquote><p>作为Android用户，看了这个视频后，我更觉得Android生态中也应该有这样的类似一个轻量级IDE的平台，为什么说“更”呢，因为<strong>一款运行于移动端平台的轻量级IDE</strong>也是我一直以来想开发的应用。不过很显然，家大业大的Google不太可能会专门开发一个像Swift Playgrounds的App，也正是因为官方没有推出这样的平台，我才对这种想法满是热情，只是说受限于我自己的技能树还没点满，还需要一段时间这个想法才有落地的可能。</p><p>所以这个视频让我又一次好好思考了一直以来酝酿的小目标。</p><hr><p>作为一个有想法<del>没技术</del>(会有的)的入门级开发者，我一直很能<strong>理解非科班但也要学习编程而又不以此为职业</strong>的朋友们，学习编程语言的第一步不是写一个<code>Hello World!</code>，而是先要进行繁琐的环境配置，对于不是有志于学习一门编程语言的学生，这个过程就能够磨灭一半的学习兴趣，更不用说还能否发现编程的乐趣了，甚至即便能够为未来的学习生活工作效率带来提升，也会本能地排斥。</p><p>而作为半个科班人，每一次重装系统或者学习新的技术栈时，也会因为搭建环境的繁复而恼火，如果是重装系统加上重新安装常用软件以及配置好所有的开发环境，基本上完整的一天时间就这么过去了，所以久而久之我的态度也转变为能忍则忍，能凑活用就不重装系统。</p><p>所以早在属于我的<code>Hello World!</code>时代，我就在思考<strong>是否存在用手机编写和运行代码的可能性</strong>，因为相较于在PC上配置繁琐的环境变量和进行复杂的设置，在移动设备上<strong>安装即用的体验</strong>对入门编程的人群来说是一个能够保持住兴趣和好奇心的绝佳方式，也是进行轻量级开发的选择之一。而让我意想不到的是居然真的有，当年有不少开发者都在探索手机编程的可行性，而基于Linux内核的Android系统也是很有希望做到这一点的。尽管始终有人表示“小屏幕不方便”、“输入法打字效率低”、“编译运行速度慢” 、“类库支持太缺乏”等等，但这个领域始终在不温不火地发展着，如今也有团队和个人在开发着<u>移动平台的代码编辑器和开发环境</u>。而在看了这支视频后，我认识到存在一个全球一流的科技公司，正在这样一个小众的需求上不断发力。同时我也有理由相信，在Android平台，依靠开源开放的生态，我们能够实现<strong>既能兼顾便捷也能不失专业的移动端开发体验</strong>。</p><p><strong>『在移动平台开发移动应用』</strong>，这就是Swift Playgrounds传递给我的一个最突出的理念。在程序语言中有一个概念叫“自举”，意思是一门编程语言的编译器或解释器也是用这门语言本身来实现的，这看似不可思议的特性实际上是对程序语言表现力的一种验证，而移动端的开发环境也颇有这种“自举”的意味，在手机或平板上能够开发出适配手机或平板的App，这就是我觉得很有意思的事情。视频中提到，如果开发AR应用，移动设备能够直接完成开发与测试的全过程，而不需要先在电脑上开发再将编译出来的安装包拷贝到手机&#x2F;平板上测试，这就是移动端编程的一个专业方向的应用。我想，“在移动平台开发移动应用”这个理念会是移动端IDE的一个机会，也许等到我这个想法能够落地的时候，可以有资格为这个领域添砖加瓦。</p><hr><p><strong><p align = "center" style = "font-size: 1.382rem">好在，我不是一个人……</p></strong></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>（撰写中）JavaScript海底两万里：Array和String</title>
    <link href="/2022/09/14/javascript-drowning-in-array-and-string/"/>
    <url>/2022/09/14/javascript-drowning-in-array-and-string/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的Array和String。</p><span id="more"></span><hr><p>在算法中，各种复杂的方案往往都基于数组；在业务中，各种复杂的逻辑往往都在加工字符串。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以说是我们接触数据结构和算法时学习的第一种数据结构了，而在JavaScript中，数组作为一种对象，它的能力远超我们对数组朴素的认知。</p><p>创建一个空数组有两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br></code></pre></td></tr></table></figure><p>前一种称作字面量的声明方式，后一种则是通过构造方法来创建的。不过在实际应用中很少采用构造方法的形式来创建数组，因为以来不够简洁，二来参数中可以传入数字来创建一定长度的空数组，但每个元素都是<code>undefined</code>，这会带来不安全因素，所以更多还是通过字面量的方式来创建数组。</p><p>在声明数组的同时可以在方括号中添加元素，由于JavaScript是动态类型的，这就赋予了JavaScript一个Java没有的能力，你甚至可以在数组中存任意类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, &#123;<span class="hljs-attr">count</span>: <span class="hljs-number">3</span>&#125;, <span class="hljs-literal">true</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);&#125;];<br></code></pre></td></tr></table></figure><p>对于很大一部分别的语言，比如C&#x2F;C++和Java，数组是一个比较单纯的东西，像数组拷贝啊动态长度数组啊之类的概念都是需要开发者手动实现的，而更进一步的数据结构诸如栈和队列，则是基于数组设计的结构。而在JavaScript中，数组拥有很强大的能力，能够直接被当作栈和队列来使用。</p><hr><p>作为队列，数组提供这些方法：</p><ul><li><code>psuh</code>在末端添加一个元素</li><li><code>shift</code>取出队列首端的第一个元素，整个队列前移。</li></ul><p>作为栈，数组提供这些方法：</p><ul><li><code>push</code>在末端添加一个元素</li><li><code>pop</code>从末端取出一个元素</li></ul><p>对于数组的首端，不仅能够取出元素，自然也能够添加元素：</p><ul><li><code>unshift</code>在首端添加一个元素</li></ul><p>所以，JavaScript允许对数组的头尾进行添加或删除的操作，也就很容易实现比如双端队列这样的数据结构。</p><p>从性能的角度来说，用于对数组首端操作的<code>shift/unshift</code>性能开销会更大，因为会移动所有的数组元素。</p><hr><p>如果要遍历数组，可以通过普通的<code>for</code>循环，这也是运行最快的方式，同时也最自由。当然，自由的代价是开发者需要关注一些细节，比如循环的起始位置，迭代的步长等等，而对于简单的遍历数组所有元素，现代JavaScript提供了<code>for..of</code>语法，可以遍历所有的元素值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>数组方法中存在一把瑞士军刀 —— <strong><code>splice</code>方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">splice</span>(start, [deleteCount, elem1, ..., elemN]);<br></code></pre></td></tr></table></figure><p><code>splice</code>方法从<code>start</code>开始修改<code>arr</code>：删除<code>deleteCount</code>个元素，在当前位置插入元素<code>elem1, ..., elemN</code>，其返回值为由被删除元素组成的数组。</p><p>如果<code>deleteCount</code>为0，则表示在<code>start</code>位置插入元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 从索引2删除1个元素，并插入3、4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br></code></pre></td></tr></table></figure><p>如果<code>start</code>为负数，则表示倒数的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<br>arr.<span class="hljs-title function_">splice</span>(-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 从倒数第二个元素开始</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 5, 4, 3, 2, 1 ]</span><br></code></pre></td></tr></table></figure><p><strong><span style = "color: red;">需要注意，<code>splice</code>方法改变了原来的数组。</span></strong></p><hr><p><strong><code>slice</code>方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">slice</span>([start], [end]);<br></code></pre></td></tr></table></figure><p>它返回一个<code>arr</code>中从<code>start</code>到<code>end</code>(不包括end)的元素组成的新数组。</p><p>如果<code>start</code>和<code>end</code>为负数则为倒数。</p><p>可见方法参数是可选的，所以如果不传参，那就相当于复制<code>arr</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// [ 3, 4 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>)); <span class="hljs-comment">// [ 2, 3, 4 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">2</span>, -<span class="hljs-number">4</span>)); <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><hr><p><strong><code>concat</code>方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">concat</span>(arg1, arg2...);<br></code></pre></td></tr></table></figure><p>用于合并多个数组，参数可以是数组或数值，参数数量不限。</p><p>这个方法不会修改现有数组，而是返回包含<code>arr</code>本身以及所有参数的新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">concat</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span><br></code></pre></td></tr></table></figure><hr><p><code>forEach</code></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>（撰写中）JavaScript海底两万里：异步</title>
    <link href="/2022/09/09/javascript-drowning-in-asynchronous/"/>
    <url>/2022/09/09/javascript-drowning-in-asynchronous/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的异步API。</p><span id="more"></span><hr><p>JavaScript主机环境提供了许多函数，这些函数允许我们执行<strong>异步</strong>行为，意思是现在开始执行的行为会在一段时间后完成，比如<code>setTimeout</code>函数。</p><blockquote><p>JavaScript最初是为Web浏览器平台而创建的，后来逐渐演变为一种具有多种用途和平台的语言，JavaScript将平台称为<strong>主机环境</strong>。</p><p>主机环境提供了自己的对象和语言核心以外的函数，比如浏览器提供了控制网页的方法，Node.js提供了服务器端功能等。</p></blockquote><p>异步编程允许我们咋i执行一个长时间任务时，程序不需要进行等待，而是继续执行之后的代码，直到这些任务完成后再回来通知你。异步编程通常是以回调函数的形式来实现，这种模式能够避免程序的阻塞。</p><blockquote><p>回调，简单来说就是把函数作为函数的参数；</p><p>回调函数，简单来说就是以函数作为参数的函数。</p></blockquote><p>在Java中，我们知道方法接收的函数都是类对象，而即便是Java8开始有了lambda表达式，而Java的函数式编程是基于函数式接口，所以从某种程度上来说它的实现仍然没有脱离类与对象。而在JavaScript中，作为一门多范式的语言，它支持纯粹的函数式编程，我们可以将函数作为参数传递给另一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">argfun</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;function called as callback&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">functional</span>(<span class="hljs-params">fun</span>) &#123;<br>    <span class="hljs-title function_">fun</span>();<br>&#125;<br><br><span class="hljs-title function_">functional</span>(argfun); <span class="hljs-comment">// function called as callback</span><br></code></pre></td></tr></table></figure><p>可以看到functional接受一个<strong>函数</strong>fun作为参数，在functional内部执行fun函数，从而输出结果。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：类</title>
    <link href="/2022/09/06/javascript-drowning-in-class/"/>
    <url>/2022/09/06/javascript-drowning-in-class/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的类<code>class</code>。</p><span id="more"></span><hr><p>在ES6之前，JavaScript中并不存在<strong>类</strong>的概念，开发者们对于原型和继承可谓是绞尽脑汁，通过各种方式来实现基于原型链的继承。</p><p>日常开发中我们经常需要创建许多相同类型的对象，在学习了构造器之后，我们可以想到通过<code>new Function()</code>的形式来实现这种需求。不过在现代JavaScript中引入了更高级的“<strong>类</strong>”的概念，它包含许多适用于面向对象的新功能。</p><p>我作为一个半吊子Java开发者，一直在与面向对象编程打交道，而连名字都蹭Java热度的JavaScript，在面向对象这块的设计跟Java不能说一模一样，只能说是大差不差，除了没有显示的<code>public</code>和<code>private</code>字段之外，别的方面基本都是相通的。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    &lt;prop&gt; = &lt;value&gt;;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    &lt;method1&gt;() &#123;&#125;<br>    &lt;method2&gt;() &#123;&#125;<br>    &lt;method3&gt;() &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是声明一个类的例子，可以看到JavaScript采用显示的<code>constructor</code>关键字来声明构造方法，而不是像Java那样用与类名相同的方法。</p><p>在JavaScript中，类的本质是函数，所以它不完全是语法层面的特性。JavaScript的类的底层实现事实上是构造器<code>constructor</code>和原型(链)<code>[[Prototype]]</code>。当我们<code>new</code>一个对象时，JavaScript会通过以类名命名的构造器来创建对象。</p><p>但这并不意味着<code>class</code>就仅仅是一个语法糖，它们之间还是存在一定差异的：</p><ol><li>通过<code>class</code>创建的函数内部包含<code>[[IsClassConstructor]]: true</code>属性标志，解释器会检查这个属性来判断是否存在语法错误。</li><li>类方法不能枚举，当对一个对象调用<code>for..in</code>时不会出现类方法。</li><li>类自动采用<code>&quot;use strict&quot;</code>模式。</li></ol><h2 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h2><p>与方法一样，类也可以在另一个表达式中被定义、赋值、传递、返回等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类名Hello将将仅在类内部可见</span><br><span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 返回一个类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnClass</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> &#123;<br>        <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>之前说JavaScript中类的底层是基于构造器和原型(链)，类的继承就是通过原型链来实现的。</p><p>还是那句话，跟Java很像，通过<code>extends</code>关键字可以实现继承，子类的构造方法也必须先调用父类<code>super</code>的构造方法。</p><blockquote><p>一个特殊情况是箭头函数，箭头函数不仅没有<code>this</code>，也没有<code>super</code>，如果在箭头函数中访问<code>this</code>或<code>super</code>，它会从外部函数获取，所以能够融入到就近的上下文中。</p></blockquote><p>在Java中我们经常继承标准库中的一些类，比如继承<code>Thread</code>来实现线程，在Android开发中也需要继承<code>Activity</code>来编写我们自己的逻辑，而JavaScript也不例外，它的内建类也可以被继承，但是需要注意的一点是内建类相互间不继承静态方法，因为继承关系并不存在于这些类之间，而是存在于它们的<code>prototype</code>之间，注意是<code>prototype</code>而不是<code>[[Prototype]]</code>。</p><pre><code class=" mermaid">flowchartnewDate[&quot;new Date()&quot;]subgraph 结构direction BTsubgraph 原型链direction BTnewDate --&gt;|&quot;[[Prototype]]&quot;| Date.prototypeDate.prototype --&gt;|&quot;[[Prototype]]&quot;| Object.prototypeendsubgraph 类direction BTDate ---|&quot;×&quot;| ObjectendendDate --&gt; Date.prototypeObject --&gt; Object.prototype</code></pre><h2 id="静态属性-amp-静态方法"><a href="#静态属性-amp-静态方法" class="headerlink" title="静态属性&amp;静态方法"></a>静态属性&amp;静态方法</h2><p>在属性或方法前添加<code>static</code>关键字，对Java用户来说无需多言。</p><p>静态属性和方法也能够被继承。</p><h2 id="怎么实现private属性和方法"><a href="#怎么实现private属性和方法" class="headerlink" title="怎么实现private属性和方法"></a>怎么实现<code>private</code>属性和方法</h2><p>在JavaScript中没有像<code>public</code>和<code>private</code>这样的关键字，开发者之间存在一个约定，私有的属性或方法的命名通常以下划线<code>_</code>开头。</p><p>不过在新标准中，如果属性和方法的名字以井号<code>#</code>开头，它们将只能够在类内部可以被访问，这是语言级别的特性。</p><h2 id="类检查-instanceof"><a href="#类检查-instanceof" class="headerlink" title="类检查 instanceof"></a>类检查 <code>instanceof</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;child&gt; <span class="hljs-keyword">instanceof</span> &lt;parent&gt;<br></code></pre></td></tr></table></figure><p>如果<code>child</code>属于<code>parent</code>及其子类则返回<code>true</code>。<code>instanceof</code>在检查中会将原型链考虑在内。</p><p>再说一个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;objA&gt;.<span class="hljs-title function_">isPrototypeOf</span>(&lt;objB&gt;);<br></code></pre></td></tr></table></figure><p>如果<code>objA</code>在<code>objB</code>的原型链中则返回<code>true</code>。</p><p>所以如果把上述<code>instranceof</code>的例子改为<code>isPrototypeOf</code>方法，我们需要判断<code>parent</code>是否在<code>child</code>的原型链中，即判断<code>parent</code>是否为<code>child.__proto__.__proto__.__proto__...</code>中某一个父类的对象。</p><p>我们都知道<code>typeof</code>关键字可以判断一个对象的类型，而日常开发中看似不起眼的<code>toString</code>方法事实上可以比<code>typeof</code>和<code>istanceof</code>更加强大，我们可以通过方法借用<code>func.call</code>来实现这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我们让一个数组借用Object的toString方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]));<br></code></pre></td></tr></table></figure><p>可以看到打印了<code>&quot;[object Array]&quot;</code>。</p><p>所以说通过<code>toString</code>方法也可以检查对象的类型。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：[[Prototype]]、__proto__、prototype</title>
    <link href="/2022/09/05/javascript-drowning-in-prototype-properties/"/>
    <url>/2022/09/05/javascript-drowning-in-prototype-properties/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚<code>[[Prototype]]</code>、<code>__proto__</code>、<code>prototype</code>的区别与联系。</p><span id="more"></span><hr><p>在学习JavaScript原型相关内容时，包含”proto”的属性着实不少，各自都有不同的含义。</p><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p><code>[[Prototype]]</code>是<strong>对象的隐藏属性</strong>，可以认为是一个<strong>概念</strong>，表示该对象的原型。</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p><code>__proto__</code>是<strong>JavaScript提供的访问对象原型的方式</strong>，通过<code>obj.__proto__</code>可以访问到<code>obj</code>的原型，只不过现代JavaScript更加推荐使用<code>Object.getPrototypeOf(obj)</code>和<code>Object.setPrototypeOf(obj, [descriptors])</code>来获取和设置对象<code>obj</code>的原型。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p><code>prototype</code>是针对函数而言的，只有函数才有这个属性。比如<code>F</code>是一个构造函数，对于<code>F.prototype</code>，<code>F.prototype = protoObj;</code>表示**当创建了一个<code>new F</code>时，新对象的<code>[[Prototype]]</code>会被赋值为<code>protoObj</code>，也就是<code>F.prototype</code>**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> protoObj = &#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = protoObj;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <span class="hljs-comment">// obj.__proto__ === F.prototype</span><br></code></pre></td></tr></table></figure><p>简单来说，<code>F.prototype</code>就是调用构造函数<code>F</code>时创建的对象的原型，可以认为这个“原型”是对象的***<u>模板</u><em><strong>，这与Java中</strong>类是对象的模板</em>*的理念同样非常相似。</p><h2 id="原型与原型继承"><a href="#原型与原型继承" class="headerlink" title="原型与原型继承"></a>原型与原型继承</h2><p>我们必须要区分这两个概念：构造方法的原型属性<code>F.prototype</code>是一个模板，它可以创建以此为参考的新对象；原型继承表示多个类之间的继承关系，通过<code>__proto__</code>可以读取和设置某个对象的<code>[[Prototype]]</code>属性，即设置该对象的父类。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>对于两个构造方法<code>Parent</code>和<code>Child</code>，<code>Child</code>从<code>Parent</code>继承，我们可以通过<code>new Parent()</code>和<code>new Child</code>来创建两个对象<code>parent</code>和<code>child</code>。</p><p>于是，我们可以得到以下推论：</p><ul><li><code>child.__proto__ === parent === Parent.prototype</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：原型(链)</title>
    <link href="/2022/09/03/javascript-drowning-in-prototype/"/>
    <url>/2022/09/03/javascript-drowning-in-prototype/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的原型(链)。</p><span id="more"></span><hr><p>Java选手们很容易看出来，如果存在三个类<code>User</code>、<code>Admin</code>、<code>Guest</code>，这三个类之间可以存在继承关系，像这样：</p><pre><code class=" mermaid">flowchart BTAdmin --&gt;|&quot;[[Prototype]]&quot;| UserGuest --&gt;|&quot;[[Prototype]]&quot;| User</code></pre><p>在JavaScript中，<strong>原型继承</strong>可以用来实现对象继承的能力。</p><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a><code>[[Prototype]]</code></h2><p>在JavaScript中，对象有一个<strong>隐藏属性</strong><code>[[Prototype]]</code>，称为<strong>“原型”</strong>，它要么是<code>null</code>，要么是另一个对象的<strong>引用</strong>。</p><p>当我们从对象中读取一个<strong>缺失的属性</strong>，JavaScript会从原型中获取该属性，这称为<strong>“原型继承”</strong>，我们后面细看。</p><p>所谓<strong>隐藏属性</strong>，指<code>[[Prototype]]</code>是对象内部的，而且是隐藏的，可以说相当于Java中的private字段。</p><p>但就如同Java中可以设置<code>getter/setter</code>方法一样，JavaScript中也存在设置<code>[[Prototype]]</code>的方式，不过不同于Java中通过<code>extend</code>关键字来实现继承，一种方法是使用<code>__proto__</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = &#123;<br>    <span class="hljs-attr">jump</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>rabbit.<span class="hljs-property">__proto__</span> = animal; <span class="hljs-comment">// 此时rabbit的原型被设置为animal</span><br></code></pre></td></tr></table></figure><p>现在，如果执行<code>console.log(rabbit.eats)</code>，JavaScript引擎会顺着<code>[[Prototype]]</code>引用，从原型链中寻找<code>eats</code>属性。</p><p>不止访问属性，当访问对象中不存在的函数，JavaScript引擎也会从原型中寻找这个函数。</p><p>如果存在这样一条原型链：</p><pre><code class=" mermaid">flowchart BTShortHair --&gt;|&quot;[[Prototype]]&quot;| Cat --&gt;|&quot;[[Prototype]]&quot;| Animal</code></pre><p>当我们从<code>ShortHair</code>中读取一些它不存在的内容，那么JavaScript会先从<code>cat</code>中查找，然后在<code>animal</code>中查找。</p><p>原型链中存在两个限制：</p><ol><li>引用<strong>不能形成闭环</strong>，如果在闭环中分配<code>__proto__</code>，JavaScript会报错。</li><li><code>__proto__</code>的**值只能是对象或<code>null</code>**，其他的类型都会被忽略。</li></ol><p>与Java相同，JavaScript也是<strong>单继承</strong>的。</p><p><strong>但是事实上<code>__proto__</code>有点过时了，它是<code>[[Prototype]]</code>的<code>getter/setter</code>，现代JavaScript建议使用<code>Object.getPrototypeOf/Object.setPrototypeOf</code>来取代<code>__proto__</code>，这两个函数后面再说。</strong></p><blockquote><p>在这里需要了解一下**<code>getter/setter</code><strong>，它们也属于对象的属性，称为</strong>访问器属性<strong>，本质上是一类</strong>用于获取和设置值的函数**，但看起来就像常规属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">propName</span>() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">propName</span>() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是，在读取<code>obj.propName</code>时，<code>getter</code>起作用；在设置<code>obj.propName</code>时，<code>setter</code>起作用。</p><p>比如这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">surname</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.surname&#125;</span>`</span>;<br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">name</span>) &#123;<br>        [<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>] = name.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>&#125;;<br><br>user.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;John Smith&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">fullName</span>); <span class="hljs-comment">// John Smith</span><br></code></pre></td></tr></table></figure><p>这样我们就设置了一个“虚拟”属性<code>fullName</code>，可以对其进行读写操作。</p><hr><p>属性具有三个<strong>属性标志</strong>：</p><ul><li><code>writable</code>：如果为<code>true</code>，则值可以被修改，否则为只读。</li><li><code>enumerable</code>：如果为<code>true</code>，会被在循环中列出。</li><li><code>configurable</code>：如果为<code>true</code>，则此属性可以被删除。</li></ul><p>而相较于普通的属性标志，<strong>访问器属性</strong>没有<code>value</code>和<code>writable</code>标志，这很好理解，<code>get</code>和<code>set</code>的存在就是读取与设置<code>value</code>，同时<code>set</code>是否存在也就决定了一个属性是否<code>writable</code>。</p></blockquote><h2 id="F-prototype"><a href="#F-prototype" class="headerlink" title="F.prototype"></a>F.prototype</h2><p>在<a href="https://skycurtain-dreamland.netlify.app/2022/09/01/dive-in-javascript-for-constructor/">上一篇</a>中我们可以知道，通过<code>new F()</code>的语法可以用构造函数创建一个新对象，而对于构造函数<code>F</code>，如果为它设置属性<code>F.prototype</code>的值是一个对象，那么当执行<code>let obj = new F();</code>时，<code>new</code>操作符会使用<code>F.prototype</code>为新对象<code>obj</code>设置<code>[[Prototype]]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>    <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = aniamal;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-property">eats</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面的代码中，<code>Cat.prototype = aniamal;</code>的意思是当<code>new Cat(...)</code>时，把新对象的<code>[[Prototype]]</code>赋值为<code>animal</code>。</p><p><strong>注意</strong>，<code>F.prototype</code>是<code>F</code>的一个名为<code>&quot;prototype&quot;</code>的属性，这是<strong>每个函数都有的属性</strong>，而不是代表<code>F</code>的原型，并且<code>F.prototype</code>的变化对已经创建出来的对象时没有作用的。</p><p>默认情况下，<code>F.prototype</code>是一个只有属性构造器的对象，构造器指向函数自身。</p><h2 id="原生的原型"><a href="#原生的原型" class="headerlink" title="原生的原型"></a>原生的原型</h2><p><code>&quot;prototype&quot;</code>属性在<code>JavaScript</code>的底层有广泛的应用，所有的内建函数都用到了它。</p><p>不愧叫<code>JavaScript</code>，在原型这方面，它的思想跟<code>Java</code>的<code>Object</code>类也有异曲同工之妙：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title function_">alert</span>(obj); <span class="hljs-comment">// [object Object]</span><br></code></pre></td></tr></table></figure><p>我们创建了一个空对象<code>obj</code>，但还是可以看到成功输出了<code>obj</code>的信息，那么很明显是内建的<code>toString</code>函数运行的结果，但是它在哪里呢？</p><blockquote><p>注意，如果用<code>console.log()</code>输出<code>obj</code>，那么在命令行只会看到<code>&#123;&#125;</code>表示空对象，只有通过<code>alert()</code>才能在浏览器中看到<code>[object Object]</code>弹窗。</p><p>默认情况下，<code>toString()</code>方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code>返回 <code>&quot;[object type]</code>“，其中<code>type</code>是对象的类型。</p><p>所以，<code>[object Object]</code>就表示Object对象。</p></blockquote><p>我们知道<code>let obj = &#123;&#125;;</code>与<code>let obj = new Object();</code>是一样的，而<code>new Object()</code>是一个构造函数的调用，<strong>Object的<code>prototype</code>指向一个包含一堆方法的对象，当然也包括了<code>toString()</code><strong>，这与Java中</strong>Object作为所有类的父类</strong>的理念有所雷同，所以，当<code>new Object()</code>被调用或<code>&#123;&#125;</code>被创建，这个对象的<code>[[Prototype]]</code>就会被设置为<code>Object.prototype</code>，而<code>toString()</code>方法正是从中获取的。其他的内建对象像Array、Date等等也都在prototype上挂载了方法。</p><p>按照规范，<strong>所有的内建原型顶端都是<code>Object.prototype</code><strong>，所以才会有“</strong>一切都是从对象继承而来</strong>”的说法。</p><p>对于基本类型，同样与Java很像，JavaScript提供了临时包装器在试图访问它们的属性时通过内建构造器<code>String()</code>、<code>Number()</code>、<code>Boolean()</code>创建，使开发者能够操作字符串、数字、布尔值，“临时”意味着这些包装器在操作结束后就会被垃圾回收器回收。</p><p>原生的原型可以被修改，但是非常不建议这么做，因为会导致严重的冲突问题，除非需要在久JavaScript环境中实现新标准的方法，这被称为polyfilling。</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><p>之前说过，通过<code>obj.__proto__</code>设置&#x2F;读取原型已经是过时的方法了，现代JavaScript中推荐通过以下方式来实现：</p><ul><li><code>Object.getPrototypeOf(obj)</code> —— 返回对象<code>obj</code>的原型</li><li><code>Object.setPrototypeOf(obj, proto)</code> —— 将对象obj的原型设置为proto</li></ul><p>此外，通过<code>Object.create(proto, [descriptors])</code>可以利用规定的proto作为原型以及可选的描述属性来创建一个新对象。这个方法非常强大，因为可以为对象添加额外的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> animal = &#123;<br>  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> rabbit = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(animal, &#123;<br>  <span class="hljs-attr">jumps</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-title function_">alert</span>(rabbit.<span class="hljs-property">jumps</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>还可以实现一种浅拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj),<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj)<br>);<br></code></pre></td></tr></table></figure><p>使用 <code>Object.create(null)</code> 或 <code>&#123;__proto__: null&#125;</code> 还可以创建无原型的对象,这些对象被用作字典，以存储任意（可能是用户生成的）键。</p><p>通常，对象会从 <code>Object.prototype</code> 继承内建的方法和 <code>__proto__</code> getter&#x2F;setter，会占用相应的键，且可能会导致副作用。原型为 <code>null</code> 时，对象才真正是空的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript海底两万里：构造器</title>
    <link href="/2022/09/01/javascript-drowning-in-constructor/"/>
    <url>/2022/09/01/javascript-drowning-in-constructor/</url>
    
    <content type="html"><![CDATA[<p>争取一文帮自己搞清楚JavaScript中的构造器。</p><span id="more"></span><hr><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>在JavaScript中，我们通常使用<code>let obj = &#123;...&#125;;</code>的方式来创建一个对象，或者是通过<code>let obj = new Object();</code>的方式，前者属于字面量的方式，而后者就是本篇要聊的话题之一 —— 构造器<code>Constructor</code>。</p><p>常规的<code>&#123;...&#125;</code>语法允许创建一个对象，然而有时候需要创建很多类似的对象，例如多个用户或者菜单项等等，这类需求可以通过构造函数与<code>&quot;new&quot;</code>操作符来实现。</p><p>构造函数在技术上与常规函数相同，但是存在两个<strong>约定</strong>（不是规定）：</p><ol><li>它们的命名以大写字母开头</li><li>它们只能由<code>&quot;new&quot;</code>操作符来执行</li></ol><p>一个例子可以像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br></code></pre></td></tr></table></figure><p>这跟Java的构造方法其实有几分相似之处。在Java中，我们通过<code>new</code>一个<code>class</code>的方式在创建一个对象，实际上Java会调用这个类的构造方法来创建对象。而在JavaScript中，我们不需要像Java那么规范地先写<code>class</code>再写构造方法，**JavaScript的构造函数能够在通过<code>new</code>操作符执行时候创建一个新的空对象并分配给<code>this</code>**，函数体中的内容会修改<code>this</code>的属性，最后返回<code>this</code>。</p><p>技术上来说任何函数都可以作为构造器，但箭头函数除外，它没有自己的<code>this</code>。</p><p>对于最后“返回<code>this</code>”的这个步骤，其实是解释器帮助我们完成的，因为我们不需要显式地写出<code>return</code>语句，但并非不允许在里面写<code>return</code>。<code>return</code>语句存在一条规则：如果<code>return</code>返回一个对象，那么就返回这个对象，其他情况都返回<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span> &#125;; <span class="hljs-comment">// 返回一个对象</span><br>&#125;<br><br><span class="hljs-keyword">let</span> newUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newUser); <span class="hljs-comment">// &#123; name: &#x27;Jack&#x27; &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回非对象</span><br>&#125;<br><br><span class="hljs-keyword">let</span> newUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newUser); <span class="hljs-comment">// User &#123; name: &#x27;John&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p>所以用构造函数来创建对象具有很大的灵活性，其实这跟Java还是比较类似的，可以暂时参考Java的类来理解JavaScript的构造函数，所以构造函数中不仅可以添加属性，也可以添加方法，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, my name is John.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JavaScript海底两万里</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从反馈bug到想造轮子</title>
    <link href="/2022/08/29/from-reporting-bugs-to-wish-inventing-wheels/"/>
    <url>/2022/08/29/from-reporting-bugs-to-wish-inventing-wheels/</url>
    
    <content type="html"><![CDATA[<p>开发者的自己的项目中，是否应该在第三方类库的引用上保持最大程度的洁癖呢？</p><span id="more"></span><hr><p>自从<del>宇宙第一 Markdown编辑器</del><strong>Typora</strong>宣布收费后，我始终没有下定决心购买正式版，一是由于付费后获得的能力和解锁的功能并不是我必须的，二是因为我发现了不错的 vscode插件，基本可以胜任我写内容的场景，并且Markdown对我来说目前的作用就是写博客，而在vscode中事实上能够更加一体化地管理博客。</p><p>然而用了几个月我都没有发现这个插件居然不支持用于设置摘要的 <code>&lt;!-- more --&gt;</code>，发现时是因为看到首页中所有文章的摘要都失效了。</p><blockquote><p>在文章中使用 <code>&lt;!-- more --&gt;</code>，那么 <code>&lt;!-- more --&gt;</code> 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p></blockquote><p>因为我习惯于为文章添加一句引子，也就是正文的第一句，不支持摘要的结果是引擎会截取尽可能多的字数作为摘要，虽无伤大雅，但总归不爽。不过我发现作者更新频率还是很高的，于是便打算等几天，但并没有发现更新了对Hexo摘要的支持，看来我这个社恐只能发邮件向作者反馈一下了，可是得到的回复是：</p><blockquote><p><strong>插件的原理是解析 Markdown语法，因此一切非Markdown语法的内容都会被忽略</strong>。</p></blockquote><p>很可惜，看来作者的开发思路跟Typora有所不同，但这也怪不得开发者，毕竟是用爱发电的作品，作者必然是以满足自己的使用需求为第一要义，除非给钱让开发者定制，不然也很难去提什么主观的要求。</p><p>虽然还在学习前端的我在开发vscode插件这方面没什么能力，但是此刻却萌生了想要开发一款Markdown编辑器的欲望。</p><p>不过很幸运，我发现了另一款插件，同样能够满足我写博客的需求，然而在更新了一个版本之后出现了一些主题适配的问题，并且同样没有发现修复更新，很无奈我再一次发邮件向开发者反馈，这一次的反馈很顺利，作者也是邮箱高强度在线，讲清楚问题后20分钟就修复了bug并推送新版。</p><p>很开心，但同时我也在思考，如果这位开发者没有排查出问题，甚至没有回复我，那么这些插件对我来说使用体验就会大打折扣了，所以我还是有想自己开发Markdown编辑器的欲望。</p><hr><p>这就是程序员们常说的“造轮子”了，而且是重复造轮子，因为已经有了功能相似甚至相同的产品出现。造轮子的初衷实际上是源于自己对现有产品的不满足，比如功能无法完整覆盖自己的需求，比如已经失去维护很长时间，甚至是业界并没有符合自己设想的项目……但是我时常在想，当在自己的项目中引入了这些开源的库之后，如果这些库出现了问题，就像fastjson频繁曝出安全漏洞，此时该自己从头实现一套专属当前场景的工具库还是继续另寻其他开源库呢？</p><p>对我来说，我觉得自己是有一些代码洁癖的，对源码的好奇让我时常会思考某个功能在底层是如何实现的，有时还会尝试去实现标准库的某个函数，但是当我在前几个学期完成大作业的过程中，却对手写工具类有所排斥，果断地暂时将底层原理抛诸脑后，对现成的工具和类库，只要能实现需求，便只管拿来主义。事实上我是有些惭愧的，然而大作业是要实现需求的，需求只是一句话，是不会考虑业务逻辑的复杂度的，此时实现需求才是第一要义，调用的库存在什么关键细节并不需要考虑，因为类库就应该由它的开发者来维护。</p><p>不过我总觉得这看来像是自己的项目中有一些关键内容被别人握在手里，虽然开源协议可以保护自己的软件不会遭到类库开发者的“制裁”，但调用别人写的代码总是感到不够安心，如果是一些嵌入项目比较深的组件，原作者进行了改动后很可能自己要跟着修改很多逻辑，这种被动想必不会那么自在。</p><p>就我个人的感受来看，这是一种复杂的心理，当在完成一个任务的过程中，我通常是属于只看结果的那一类人，只要有可以实现需求的方案，那就可以拿来用，而不考虑是否有必要总结出一套代码库出来，在当下的网络世界，几乎所有在开发过程中遇到的问题都能够寻找到答案。</p><p>而当我在酝酿自己的项目时，往往想要追求<strong>每一行代码都来自于自己的双手在键盘上的敲击</strong>，不论业界是否存在一些成熟的解决方案。自己的项目，我就希望所有的东西都是我自己手搓出来的，当然，即便一时半会为了开发进度而需要引入一些现成的库，在未来我也愿意重新实现项目中调用的函数，当项目中所有的代码都是我自己的劳动成果，我才踏实地感到这是我自己的产品，我是有完整的决定权和发言权的。</p><hr><p>所以我觉得对于个人项目而言，引用官方的开源库自然不会有太大问题，但是我觉得对于别人的开源项目的引用还是要保持一定的克制，毕竟不知道开发者会维护多久，这意味着很有可能在未来你依然需要基于人家的项目做维护，而理解别人的代码对任何人来说都绝非易事。事实上基于现有的开源库来开发应用就像拼图一样，或许拼图很简单，但一旦丢失了一块碎片，整张拼图将不能再复原，而从开发者的角度来说，如果你对技术有兴趣，那么设计一款属于自己的“拼图”一定会比单纯的“拼图”更有趣。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>答辩之殇</title>
    <link href="/2022/06/09/mourning-of-defense/"/>
    <url>/2022/06/09/mourning-of-defense/</url>
    
    <content type="html"><![CDATA[<p>这些老学究们到底对什么样的答辩项目更感兴趣呢？</p><span id="more"></span><hr><h2 id="idea的夭折"><a href="#idea的夭折" class="headerlink" title="idea的夭折"></a>idea的夭折</h2><p>炼丹机器学习要求凌驾于热门行业的创新点（本科预言家是吧），管理系统又认为没有含金量转而极其要求界面的美观（自己招标的教务系统不也丑得极具个性），本应体现唯性能论的项目却成为了面向普通用户设计的系统性软件（为什么有些优秀的分析器根本没有UI），使用当下主流的开发框架又被质疑如此平平无奇的信管系统是否需要那么多前后端框架提供支持（造不造轮子都没好话），同时数据库设计又变成了没有含金量的步骤（不做好设计被开除八百次都死有余辜），而代码量甚至也会成为评价指标之一（把框架源码也算进去行不行）······有些<strong>满含金点子</strong>的项目，很可能就在无情的毒打之中被扼杀在摇篮。</p><blockquote><p>这些奇怪的建议真的能够为<strong>高校向社会输送人才</strong>的理念提供一点利好吗？</p><p>这些大部分早已与主流技术栈脱轨的老学究们真的能够拓展大学生的视野吗？</p><p>人人做研究，难道就一定会提高全国的研究水平吗？</p></blockquote><h2 id="当我们答辩时我们在干什么"><a href="#当我们答辩时我们在干什么" class="headerlink" title="当我们答辩时我们在干什么"></a>当我们答辩时我们在干什么</h2><p>这学期中在自己经历了三场课程项目答辩，有幸看过隔壁专业的毕业设计答辩，网上冲浪看到一些学生网友的答辩实录，以及参观了身处新兴一流高校的朋友的课程项目答辩后，我难以抑制自己产生上述的疑问。</p><p>在我看来，任何一套有助于提升开发者工作效率的开发框架都是其背后或个人或团队的技术与智慧的结晶，开发框架使大量的开发者不用关注大量操作系统底层与网络底层的实现细节，关注于业务功能的实现就好，然而在使用了开发框架后，你的项目很有可能就会变成“工作量不够”，而事实上，当我学通了计算机网络、操作系统，用几门程序语言硬是从底层造出了一个功能，写了上千行代码，得到的评价又会变成“这不都有现成的库吗？你自己写出来有什么新意呢？”。所以也可以说是学生们变聪明了，我们知道要想办法去做一些集合了一大堆功能的app，最好是一个网站服务，于是很自然地，学生们都想到了各种管理系统。</p><p>但久而久之，学生们也苦于老师们看腻了各种管理系统，于是项目的思路设计开始往热门的机器学习、模式识别，智能决策这些方面去靠，但是这类建立在大量学科基础知识上的应用又岂是我辈普普通通的本科生能够速成的，况且辛苦造出来的“轮子”也大概率比不上大厂造出来的“车”，那不如直接去找现成的模型或API集成到自己的平平无奇管理系统，于是评价又变为“你们的理解好像有点问题”或是“你们的数据集和模型是怎么来的？”这样暴露本质的问题。</p><p>看来不论是什么样的项目，哪怕是比得上一线互联网大厂的app产品，答辩上都会收到一些无趣、无理的问题。于是逐渐地，答辩就成为了一场<strong>如何把老师忽悠转</strong>的表演赛，用高级的话术、包装的语言，让评委老师认为这是及其有前景的项目，自己恨不得掏几百万出来投资入股，那你的表演就差不多到位了，成绩也就基本令人满意了。说来可笑，有点像是骗融资的，其实不假，毕竟有些高校工作者也是毕生追求科研经费呢。</p><p>所以，当我们答辩时我们在干什么？在最近的一场线上答辩，我们小组在从答辩开始到轮到我们组的两个多小时中，一边听着大会一边开着小会，进一步测试项目功能实现的同时盘点前面各小组项目得到的评价，以此来调整我们投屏演示时的话术，注意说话的细节，注意避开前面小组遇到的坑······很幸运，一路下来还算顺利，只是感到一点都不自在。</p><h2 id="软件项目的答辩需要什么"><a href="#软件项目的答辩需要什么" class="headerlink" title="软件项目的答辩需要什么"></a>软件项目的答辩需要什么</h2><p>仅在我看来，也仅从计算机相关专业来看，我所遇到的老师中，有很多都没有当下软件技术的工程经验，在很多专业相关的课程中，我几乎没有听到过任何与“公司”“工程”相关的词汇和字眼，我愿意相信他们并非不学无术，也许在学术研究与工程应用中间真的存在一堵很厚的高墙，这些老师能把理论理解得极为透彻，而他们对工程应用的理解或许还在十年之前，当我们用上新的程序语言、新的开发框架、新的UI组件，老师们就很难针对项目本身提出问题和建议了。当然，也有很多老师，相比之下他们就有明显的开发经验，至少这些老师敲起代码是十分熟练的。我们时常抱怨，如果是他们来带我们的课设就好了，但为什么不是呢？或许是他们的级别不够吧。</p><p>总有人说，计算机专业的核心是哪些亘古不变的计算机原理，以及形成一种计算机思维和素养，编程语言并不是第一要义。但事实上，程序代码的地位应当是计算机动态运行的一种静态体现，这是很重要的角色。作为高校鄙视链中的一员，我们对高职时常有一种理所当然的自信，但我们经常能够在一些比赛中名单中看到，这些来自“培训班”的创意往往出乎我们意料。如果说教授亘古不变的计算机原理是大学胜于高职的地方，那么实践项目的古板、陈旧就像开着一辆慢吞吞的老爷车在高速公路上，没有人会羡慕你的历史价值，别人只会嘲笑你跑得太慢。</p><p>纸上谈兵式的项目实践不应该是有志于成为开发者的我们的追求，经典的计算机理论不能永远通过古董项目来作为实操，反正即便是<em><strong>最新</strong></em>的开发技术也依然要靠学生<em><strong>自学</strong></em>，只是如果在教学指导上能够给出方向，那就业市场将感激不尽。</p><p>我在<a href="https://skycurtain-dreamland.netlify.app/2021/09/19/0919-thinking/">0919：随想 | Skycurtain.Dreamland</a>中表示，只要讲座内容合理，我还是比较青睐这种讲座＋项目的模式，而这种模式放在用于所有的计算机课程设计，也应当合理。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2022-06-13</p><p>看到一个知乎问题：</p><blockquote><p>如何评价领导要用代码行数衡量每个人的工作量？</p></blockquote><p>有一个回答是这样：</p><blockquote><p>用代码量来考核程序员，</p><p>相当于用油耗高低来评价汽车，但却以为油耗高的汽车好</p><p>相当于用煤气用量来评价厨师，认为谁用的煤气多，谁更努力（结果不做饭的时候，炉子也在燃烧）</p><p>相当于用药方里药的数量来评价医生，认为药开得多的医生，更努力（讽刺的是，医院真这么干）</p><p>相当于用“送一单外卖”所花的时间来评价外卖员，“人家送了十分钟，你却只送了三分钟，你凭什么少干七分钟活？”</p><p>相当于用作业量来评价老师，学生要是有做不完的作业，那这就是一位好老师</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我感觉良好的死循环妙用：多线程协作</title>
    <link href="/2022/05/21/charm-of-endless-loop-in-multithreading/"/>
    <url>/2022/05/21/charm-of-endless-loop-in-multithreading/</url>
    
    <content type="html"><![CDATA[<p>还未曾想过死循环的条件break机制能在流程控制以外的场景中焕发光彩。</p><span id="more"></span><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>有四个线程，每个线程函数都能够接收三个整型变量（变量的值在创建线程时设定），在线程内部求出三个变量的和，在四个线程都计算完毕后，要求必须在main函数中对四个线程的计算结果再次求出总和，然后在各个线程中分别输出这个总和值。</p></blockquote><h2 id="方案逻辑"><a href="#方案逻辑" class="headerlink" title="方案逻辑"></a>方案逻辑</h2><p>程序开始运行后，主线程与子线程的协作可以这样描述：</p><blockquote><ol><li>子线程计算变量之和，主线程进入死循环，检测子线程是否计算完成。</li><li>子线程计算完成时，主线程计算总和并跳出循环，此时子线程进入死循环，检测主线程是否计算完成。</li><li>主线程计算完成后即结束运行，各个子线程输出总和。</li></ol></blockquote><blockquote><table><thead><tr><th align="center">步骤</th><th align="center">主线程</th><th align="center">子线程</th></tr></thead><tbody><tr><td align="center">①</td><td align="center">启动，初始化数据</td><td align="center"></td></tr><tr><td align="center">②</td><td align="center">循环等待子线程通知</td><td align="center">启动，各子线程计算变量之和<br />循环等待<br />各子线程计算完毕后通知主线程<br />跳出循环</td></tr><tr><td align="center">③</td><td align="center">对子线程结果再次求和<br />通知子线程<br />跳出循环</td><td align="center">循环等待主线程通知</td></tr><tr><td align="center">④</td><td align="center">结束</td><td align="center">输出结果<br />跳出循环</td></tr><tr><td align="center">⑤</td><td align="center"></td><td align="center">结束</td></tr></tbody></table></blockquote><p>两种检测都各需要一个flag作为判断条件，而且需要一个共享的空间用于保存子线程和主线程计算的结果，在需要取用时从中获取即可。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Thread[] thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= thread.length; i++)<br>            thread[i - <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(i, i, i));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= thread.length; i++)<br>            thread[i - <span class="hljs-number">1</span>].start();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.isSubFinished()) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sub : Data.getArrayList())<br>                    Data.setSum(Data.getSum() + sub);<br>                Data.finishSum();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Task.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> c;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-built_in">this</span>.a = a;<br>        <span class="hljs-built_in">this</span>.b = b;<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a + b + c;<br>        Data.addList(sum);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.getListLength() == <span class="hljs-number">4</span>) &#123;<br>                Data.finishSub();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Data.isSumFinished()) &#123;<br>                System.out.println(<br>                    <span class="hljs-string">&quot;In &quot;</span> +<br>                    Thread.currentThread().getName() +<br>                    <span class="hljs-string">&quot;, the sum is: &quot;</span> + Data.getSum()<br>                );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flagSub</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flagSum</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addList</span><span class="hljs-params">(Integer sum)</span> &#123;<br>        arrayList.add(sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">getArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getListLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> arrayList.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSum</span><span class="hljs-params">(<span class="hljs-type">int</span> sum)</span> &#123;<br>        Data.sum = sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishSub</span><span class="hljs-params">()</span> &#123;<br>        flagSub = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishSum</span><span class="hljs-params">()</span>&#123;<br>        flagSum = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubFinished</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flagSub;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSumFinished</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> flagSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">In Thread-<span class="hljs-number">1</span>, the sum is: <span class="hljs-number">30</span><br>In Thread-<span class="hljs-number">0</span>, the sum is: <span class="hljs-number">30</span><br>In Thread-<span class="hljs-number">3</span>, the sum is: <span class="hljs-number">30</span><br>In Thread-<span class="hljs-number">2</span>, the sum is: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程起步：矩阵乘法的任务分配</title>
    <link href="/2022/04/27/tasks-assignment-method-in-parallel-matrix-multiplication/"/>
    <url>/2022/04/27/tasks-assignment-method-in-parallel-matrix-multiplication/</url>
    
    <content type="html"><![CDATA[<p><del>操作系统</del>多线程编程课程设计完工后记</p><span id="more"></span><p>多线程确实是很浪漫的一个话题，不过在我还没有了解到更底层内容的现在，这种需要做性能分析的工作我还是不要尝试用Java这种高深莫测的虚拟机语言吧吧吧吧吧吧。</p><hr><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>先贴一下选题及大致要求：</p><blockquote><ul><li><p>A类</p><ol><li>线程安全型双向链表</li><li>线程安全型栈</li><li>线程安全型队列</li></ol><p>  要求对数据结构进行多线程读写测试数据正确性，读写操作需以模拟指令的形式。对于任务分配策略</p><p>  要求采用抢占与固定分配两种策略</p><p>  要求列出每个线程起止时间、所处理的命令条数、耗时，再列出总耗时。</p></li><li><p>B类</p><ol><li>并行最短路径计算：地图信息存放在map文件中，该地图至少包含2000个结点</li><li>并行排序：需要排序的数字是整数，存放于一个data文件中，大约有100万的数据量。</li><li>并行矩阵乘法：矩阵A和矩阵B都存放于matrix文件中，大小都为1024*1024，写程序计算矩阵A和B的乘积。（1）在你的电脑中运行，几个线程的计算速度最快？给出你的图表和数据分析（2）如何通过优化你的数据结构和计算过程，提高计算效率，缩短计算时间？请以图表的形式给出你每次优化后的程序版本的计算时间，分析计算速度提升的原因。</li><li>图像批量二值化：图像数量≥2000</li><li>页面图像切分</li><li>多线程书法字匹配（这老师就是搞书法字体匹配的）</li><li>多线程爬虫</li></ol></li></ul></blockquote><p>我不得不吐槽一下这个所谓的操作系统课程设计，题目不是要求实现线程安全的数据结构就是要求实现多线程需求的性能分析，在我看来这完全就是应用层面的东西，完全跟底层实现没有一点关系。在去年我曾留意过操作系统课设的要求，那时候还是要求学生去<strong>模拟操作系统的某些调度算法</strong>，今年估计是要冲什么业绩，把大纲改得又红又专不说，题目被改成这个样子，指导老师也是一言难尽。但话说回来也没有什么办法，固然有些勇士是敢于等到之后再考虑修这门课，但我不太愿意将本不该有任何课程的学期添上一件可以半年前就搞定的破事，于是便开始了为期2周的多线程编程学习。</p><h2 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h2><p>考虑课设<strong>要求进行性能分析</strong>，所以权衡之下我选择了并行矩阵乘法，毕竟矩阵乘法是早已学过的数学知识，相当于业务需求已经烂熟于心，只需要学好多线程就可以开工。</p><blockquote><p>矩阵乘法是一个非常好理解的模型，在我的设想中，由用户给出矩阵的规模$n$，接着由系统生成两个符合规模的方阵$A$和$B$，然后再由用户设置计算时的线程数，系统通过多线程计算将结果存入结果矩阵$R$，并记录每次计算的相关信息与耗时，且以合适的可视化方案反馈给用户。</p></blockquote><p>在学了个七七八八之后，我开始思考如何让这么多线程去合理地计算几百万个数据，从而得到由100多万个元素组成的结果矩阵，摆在我面前的有两种方案，一是加锁，或许更符合指导老师的本意；二是无锁，追求更好的性能。</p><p>由于深受线程同步理念的<del>毒害</del>，我决定给并行矩阵乘法加锁，每个线程每次计算一个元素，多个线程通过抢占的方式共同完成所有的计算任务，通过设置一个共享的<strong>自增计数器</strong>来判断计算过程是否结束。这看起来非常合理，是一个好办法，非常典型的多线程程序模型对吧，但是我发现一个可能因为我没有深入研究而没有解决的问题：当我将这个计算过程包装在一个循环中以便探寻在不同并发数下的耗时情况时，除了第一次外，其余轮次计算的耗时全部被“优化”成了0ms，我确信我的代码逻辑没有问题，那会不会是循环中的整个计算过程并没有那么完整？于是我将读取数据的方法也添加到循环体中，这一次很幸运，每一次的耗时都是通过真实运行计算出来的，但是每次计算都要从！文！件！去读数据，这是一件很恐怖的事情，对于<strong>1024×1024</strong>规模的矩阵，还是<strong>2</strong>个，光是读数据就要耗费七八秒的时间，这为了得到测试数据就要花几天时间，对于期望赶紧速通这个课设的我来说是万万不行的。</p><blockquote><p>现在看来对于矩阵乘法而言事实上没有任何加锁的必要，或者说我设计的加锁模式就存在问题，因为在我设想的矩阵乘法模型中并没有<strong>临界资源</strong>这一概念，因为即便要对结果矩阵$R$进行写操作，其各个元素之间都是相互独立的，元素运算顺序对最终结果没有任何影响，而对于矩阵$A$和$B$则只有读操作。退一步说，即使要把结果矩阵$R$看成一个整体，由于整个运算的输入输出是严格映射的，因此并发情况下也是对结果矩阵的不同元素进行写操作，不会出现冲突。</p><p>但耗时被优化的问题我没有找到原因，猜想是与Java内部的同步机制有关，因为我的设计思想并没有入侵相关源码，出于对未知领域的严谨，有时间我会尝试进一步研究原因。</p></blockquote><hr><h3 id="线程任务分配"><a href="#线程任务分配" class="headerlink" title="线程任务分配"></a>线程任务分配</h3><p>于是一夜回到解放前，我着手开始考虑无锁方案，一个非常关键的事情是，在【<strong>将计算结果的一个元素作为一个子任务</strong>】这个前提下，如何安排这一百多万个子任务。这是一个严肃的问题，因为子任务的安排模式将直接决定每个线程需要执行的子任务数量，而其中背负子任务最多的那个苦逼线程就直接决定了本次计算的耗时，因此这个安排模式必须尽力保证<strong>每个线程分配到的子任务数量是均匀的</strong>，这样就可以保证<strong>最累的线程和最轻松的线程所计算的子任务只相差1</strong>，换句话说，不管并发线程数怎么变化，各线程执行的最大子任务数只比最小子任务数多1，而对于这个时代的CPU，计算矩阵乘法一个元素的耗时，相较于每个线程计算数万甚至数十万个元素的耗时，几乎可以忽略不计了，所以我们可以认为<strong>达到了平均分配任务的目的</strong>。</p><p>因此，我的最终目标就是：比如说对于4×4规模的方阵，假设有7个线程并发计算矩阵乘法，那么每个线程计算的子任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">1</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">2</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">3</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">4</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">5</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] <br>Thread-<span class="hljs-number">6</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>这看起来真的很美妙，把所有的子任务都按列挨个儿分给所有线程，分完整列还剩下的就顺延到下一列，多么直观的逻辑，而它实现起来也是异常简单。</p><p>首先我们先定义一个表，我擅自将它命名为任务分配表，aka英文名TAT(Tasks Assignment Table)，TAT能够表达上面这个例子的含义，但形式上需要转变一下，后面会讲到。</p><p>光有这个表还不够，我们需要为所有的子任务编号，对于规模为$n×n$的矩阵，计算得到的结果矩阵规模也为$n×n$，包含$n^2$个元素，那么编号就从1到$n^2$，例如对于4×4规模的矩阵，编号就从1到16。</p><p>准备工作就到此结束，接下来开始表演。</p><p>首先需要确定TAT的规模，确保它能够保存所有的子任务序号，因此通过$n^2\ mod\ nThreads$，即任务数对线程数取余得到余数，如果余数是0，说明能够正好均分，否则说明需要对TAT增加一列存放剩余的子任务。</p><p>TAT的每一行的行号代表线程号，这一行中的元素代表本线程需要执行哪些任务，但是作为一个整型的二维数组，TAT很难表达出$[0][0]$这样的含义，于是我们可以借助刚刚的子任务编号构建一个映射，我称之为【子任务序号——TAT映射】，顾名思义，这是把子任务序号映射在TAT上的过程，这样就能够用数字来表示各元素的下标了。</p><p>整个过程需要两次遍历矩阵来实现，当然它们之间事实上是存在数学关系的，能够用一次循环来实现，但数学总是不简单的，因此这里我们怎么简单怎么来。第一次遍历是对需要映射的位置进行标记，第二次通过按列遍历TAT来在相应位置上赋值，闲言少叙，直接看代码：</p><blockquote><p>其实这个遍历的方案是我在想到优化手段之后反过来实现的，在我自己的项目中实际上是用了那一层数学关系，在报告中写优化策略时提出了这种基于二次遍历的分配策略。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">nTasks</span> <span class="hljs-operator">=</span> length * length;<br><br><span class="hljs-comment">// build tasksTable[][]</span><br><span class="hljs-type">int</span>[][] tasksTable;<br><br><span class="hljs-comment">// initialize tasksTable size</span><br><span class="hljs-keyword">if</span> (nTasks % nThreads == <span class="hljs-number">0</span>) &#123;<br>    tasksTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nThreads][nTasks / nThreads];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    tasksTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nThreads][nTasks / nThreads + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// load all tasks to tasksTable[][]</span><br><span class="hljs-comment">// 将所有子任务序号映射到任务分配表</span><br><span class="hljs-type">int</span> <span class="hljs-variable">nTask</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 设定子任务序号遍历初始值为1</span><br><span class="hljs-comment">// 按列遍历任务分配表中与子任务数量相同的元素数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tasksTable[<span class="hljs-number">0</span>].length; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasksTable.length; i++) &#123;<br>        <span class="hljs-comment">// 当子任务序号小于等于子任务数量时将当前元素置1</span><br>        <span class="hljs-keyword">if</span> (nTask &lt;= nTasks) &#123;<br>            tasksTable[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 进行置1操作</span><br>            nTask++; <span class="hljs-comment">// 子任务序号递增</span><br>        &#125;<br>    &#125;<br>&#125;<br>nTask = <span class="hljs-number">1</span>; <span class="hljs-comment">// 重置子任务序号遍历初始值为1</span><br><span class="hljs-comment">// 按行遍历任务分配表，对其中所有置1的元素赋值子任务序号</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; tasksTable[<span class="hljs-number">0</span>].length; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasksTable.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tasksTable[i][j] == <span class="hljs-number">1</span>) &#123;<br>            tasksTable[i][j] = nTask;<br>            nTask++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="线程内部运算"><a href="#线程内部运算" class="headerlink" title="线程内部运算"></a>线程内部运算</h3><p>下一步操作是线程内部的运算过程。我们假设子任务的编号是按矩阵横向遍历顺序递增的，于是这个编号与矩阵的元素下标之间也是存在数学关系的，可以找出规律：<br>$$<br>i&#x3D;\lfloor\frac{nTask-1}{matrix.length}\rfloor<br>$$</p><p>$$<br>j&#x3D;(nTask-1)\ mod\ matrix.length<br>$$</p><p>这样就能根据编号$nTask$计算出要求的元素下标$matrix[i][j]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiplyAssignedElements</span><span class="hljs-params">(<span class="hljs-type">int</span>[] tasksGroup)</span> &#123;<br>    <span class="hljs-comment">// 遍历接收到的子任务组中所有元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nTask : tasksGroup) &#123;<br>        <span class="hljs-comment">// 由于子任务组中可能存在0，需要将其忽略</span><br>        <span class="hljs-keyword">if</span> (nTask != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将子任务序号映射为结果矩阵的元素下标[i][j]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (nTask - <span class="hljs-number">1</span>) / result.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (nTask - <span class="hljs-number">1</span>) % result.length;<br>            <span class="hljs-comment">// 计算矩阵A的第i行与矩阵B的第j列进行矩阵乘法运算得到结果C[i][j]</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; result.length; k++) &#123;<br>                result[i][j] += matrixA[i][k] * matrixB[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>为了方便理解任务分配的过程，使子任务竖着排队无疑是最直观的方案，但性能却不是最高的，要解释这个问题需要了解一些底层知识。</p><p>首先，在编译器的眼中没有多维数组的概念，所有多维数组都被横向拉长成一行放在内存中，但由于数组元素可以通过下标直接访问，编译器会根据下标直接计算出数组元素的实际地址，因此访问数据元素的不同方式没有明显的性能差距。</p><p>接下来需要了解一下局部性原理：在现代计算机的存储体系中，存在多个寄存器以及多级高速缓存，CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。这时候联系一下上一条可以发现，如果现在CPU读取的元素是$[0][0]$，寄存器中很有可能缓存了$[0][1]$而不太可能缓存了$[1][0]$，因此，由于按列分配的模式会导致TAT的行元素之间相互割裂，局部性原理难以发挥作用。</p><p>但有意思的是，在上述这种分配策略下，只需要<u><strong>互换28与29行</strong></u>就可以实现按行分配子任务了，分配效果就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] [<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] <br>Thread-<span class="hljs-number">1</span>: [<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">2</span>: [<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">3</span>: [<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">4</span>: [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] <br>Thread-<span class="hljs-number">5</span>: [<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] <br>Thread-<span class="hljs-number">6</span>: [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] <br></code></pre></td></tr></table></figure><p>如果你已经明白了上述的简单策略，那么恭喜你，你已经有了多线程编程的思想钢印，只要了解一下你喜欢的语言中多线程的语法，就可以尝试慢慢搭建整个项目了。</p><hr><h3 id="如果你也想试试"><a href="#如果你也想试试" class="headerlink" title="如果你也想试试"></a>如果你也想试试</h3><p>最后来回答一下开头我为什么说不要用Java可能会更好。</p><p>主要是在做性能分析的时候，第一步自然是计算耗时 —— 就是在启动计算之前记录一下时间，计算完毕后再记录一下时间，二者相减就得到了计算耗时，当然也可以更细致地记录各线程的运行时间，只是当时我觉得没必要，而且也并没有因为这一点被要求改进或者影响成绩。</p><blockquote><p>事实上在中期答辩上看到了一些项目被要求记录各线程耗时，一方面我觉得这种要求很抽象，另一方面，对于这个项目来说，记录下各线程耗时并不会对性能分析产生任何帮助，因为从任务分配策略上就做到了最大限度的均匀分配，不存在任务抢占，自然也就不存在线程获取的任务数量不均导致出现部分线程耗时极短或极长的问题，并且当时我的开发进度已经过半，正在设计UI及相关逻辑，而这样的改动也会对整个数据分析模块的设计产生很大的影响，所以还是勇了一把而没有去做。</p></blockquote><p>但是在测试过程中，发现数据的变化规律并不足够稳定，也就是说重复执行设计的测试方案，发现每次的耗时曲线都有些许差异，而且是在我已经禁用睿频的前提下，这意味着风扇几乎不会满载，电脑也几乎不会发热。</p><p>我不禁有些诧异，思来想去认为是JVM —— 或者说别的VM可能也一样 —— 可能并没有直接与操作系统和CPU交互来得准确，而我不可能真的把频率限制到1GHz的水平来更细致地观察，那样又会大大拉长测试的时间，最后我也只能是在测试出比较合理的曲线时及时采用。</p><p>所以如果有朋友看到也想实现一下这个项目的话，可以用C&#x2F;C++&#x2F;Go&#x2F;Rust等等这类编译型语言来尝试一下，对于Windows平台也可以用C#来实现，而Python、Java、JavaScript&#x2F;Node这类包含VM的解释型语言在性能分析方面或许会存在一些不准确的因素。</p><p><strong>注：以上内容只是我的猜测，我不排除这些不稳定现象与我的代码质量和运行环境存在一定关系，而很遗憾我只对Java有些许了解，所以在未来我也可能会尝试用别的语言实现，各位有兴趣也可以试试。</strong></p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我可以理解多线程爬虫需要设计UI来展示信息，也可以理解最短路径可以用真正意义上的地图来呈现，但是我理解不了非强制性的UI实现最后却连线程安全型数据结构都要求设计界面来展示信息。</p><p>为了要求的UI界面，必须要展示更多信息，展示更多信息就要写更多代码，况且UI线程占用系统资源的能力并不逊于多线程编程自身。虽然相较于写后端逻辑我更喜欢前端的那种表现力，但是我也对为这玩意儿开发UI感到厌恶。即便我在学习多线程的时候发现自己对多线程还比较感兴趣，但明明是关于底层设计的课设被改成提升应用层不说，更甚的是UI的加入彻底地将其变成了一个独立的应用程序，把这个课设的核心完全移出操作系统这个范围了，根本就不属于操作系统的项目。</p><p>我感兴趣的方向好像是两个极端，一是完全地与用户互动，二是彻底地与开发者交互。在我刚开始Hello World的时候，我首先想知道的就是怎么实现输入，因为实现了输入就意味着我可以控制程序运行的方向，这个程序的控制权在我的手中，慢慢地就不再仅仅乐于在命令行里折腾，想去实现真正的界面，那种灵动的布局、流畅的动效和严谨的适配，真是浪漫的美学与严肃的工程的完美结合，所以去做大前端，去用图形界面与屏幕前的你开展无声的交流，这是我能想到的代码与人类之间最友好的沟通方式。</p><p>对我来说，写多了代码很不幸地激发了我对“程序是怎样产生的”这样一个话题有了好奇，不过即便是在编译原理课上学习了词法分析&amp;语法分析&amp;一点点语义分析，没有写过一行相关代码的我也感受不到这就能把我写的代码变成一个 <code>.o</code>、<code>.class</code>或者 <code>.exe</code>，所以还是很好奇这个编译的过程。在无意间翻了几十篇网刊文章后算是找到了一些有关底层原理的系列文章，希望自己有时间去跟随这些牛人，在未来有这样的可能去为框架、工具链、编译器贡献一行自己的代码。</p><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>其实没有采用这么高级的算法，只是放在这里，也许未来有时间会研究。</p><p><a href="https://blog.csdn.net/cncyww/article/details/80727732">并行矩阵乘法——Cannon算法的原理实现以及性能评测</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年终总结</title>
    <link href="/2022/01/10/2021-year-end-review/"/>
    <url>/2022/01/10/2021-year-end-review/</url>
    
    <content type="html"><![CDATA[<p>今年的春节来得比去年更早一些……</p><p>去年的跨年，我在浴室里诗意兴起，敲下一首小诗，现在看来倒是有几分艺术，因为<del>我也看不太明白了</del>。</p><span id="more"></span><hr><p>一月已经悄悄走过了10来天，其实到现在再来回想整个2021，除了家里有一些意外让我几乎白活了一个暑假之外，别的地方都还好，那些不痛快的事情就选择性忘记它们吧。</p><p>这一年依然感到没有太多时间去认真学一学自己感兴趣的技术，专业选修课也不那么有意思，就是说理论基础没觉得有什么加强，代码能力也没什么提升，也就剩下<em>和成员们用</em>Spring Boot完成了课设<strong>小</strong>项目是一段挺好的经历，说它<strong>小</strong>是因为把项目架构和需求理过一遍后发现它确实不庞大，期间遇到的困难其实都是需求建模不完整的问题，这大概主要源于大家都没有项目开发的经验吧，哪怕自己接触过需求，对需求的认知也没有那么清晰，而真正技术上的问题其实都可以在网络上找到解决方案。经过了这一次课设，我也算是对一种计算机语言与其编写的框架之间的关系有了了解，知道了如何站在巨人的肩膀上眺望远方。</p><p>开始的开始，我是对<strong>写出怎样的程序会输出怎样的结果</strong>感兴趣，但随着时间的推移，我开始好奇<strong>写出的程序如何被转化为输出的结果</strong>，也就是所谓的编译过程，什么gcc、clang、javac、cpython&#x2F;jpython、Chrome V8……我尝试搜索每一种编程语言，在百科中寻找它的编译器是用哪一种语言实现的，这给我一种非常奇妙的感觉，好像编译器&#x2F;解释器就是软件工程的<strong>终极奥义</strong>，因为有了编译器，你仿佛可以创造整个<strong>Cyber</strong>世界。</p><p>因此我个人对编译原理有几分兴趣，奈何作为专业课我实在学不太明白，以至于如今课程结束了我还并不清楚学到的各种词法语法分析是如何理解程序代码的，可能课程开设的目的就是让学生浅尝一下编译过程吧，没什么大目标的。而本来我还想找一些编译原理的书或视频来看看，也没想到选修课的实验会比专业课还耗时，剩下一点碎片也没法干什么。</p><p>虽然跨年的夜晚本质上和其他任何一个普通的夜晚都没有什么区别，但是从形式上这是一个焕然一新的标识。随着期末周的结束，最疲惫的日子也终于过去，下学期也必然不会有那么多琐事了。</p><p>这一年下来，越是写程序，越是发现自己其实是一个感性的人，我的感性驱使着我，在我感兴趣的事情中做理性的人，反之，在不感兴趣的事情中我也很难理性起来。有时候有一些想法，让自己一下子很快乐很激动，不过过了两分钟就发现确实没有什么地方能让我分享我的想法，随即也就冷静下来该干嘛干嘛去了。不过这除了让自己慢慢变得不太会说话了之外也没有太多障碍，只是不太会有领导力了吧，也无所谓，反正我也不太愿意当强硬的领导。</p><p>……</p><p>勉勉强强算是过完了一年，我还记得自己在<a href="https://skycurtain-dreamland.netlify.app/2021/09/19/0919-thinking/">0919：散谈 | Skycurtain.Dreamland</a>中挖的坑，希望在完成之时它会是一个带点小惊艳的产品，让环境配置不再是非科班学生的噩梦，让编写代码不再是桌面端系统的专属。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot 初体验：为了课设</title>
    <link href="/2022/01/08/springboot-foretaste-for-course-design/"/>
    <url>/2022/01/08/springboot-foretaste-for-course-design/</url>
    
    <content type="html"><![CDATA[<p>这学期的数据库课程设计，在我一通安利之后，我们小组接受了使用前后端分离的架构模式。</p><span id="more"></span><hr><p>对我来说，这是我从Java基础之后直接转向Web开发的一次体验，说来惭愧，大学生涯过半，这才是我第一次开发一个完整的项目，也是第一次将流行的现代化开发技术运用到实际的项目中。</p><p>其实按照Java Web技术栈的学习路径来说，我这种“不胫而走”的学习过程实在过于跳跃了，但是好在我有幸找到了还算不错的资料，这种“一步登天”并没有让我遇到很大的阻碍，在功能的需求确定之后，整个后端的搭建与开发过程还是比较顺利的，期间也新学了一些多方面的技术与工具的使用。</p><p>接下来我想叙述一下自己从创建新项目开始到最终写完接口文档过程中的几个<strong>关键点</strong>，以便给未来要构建新项目的自己一个参考与总结。</p><h2 id="从新建项目开始"><a href="#从新建项目开始" class="headerlink" title="从新建项目开始"></a>从新建项目开始</h2><p>借助全宇宙第一的IDE —— <del>喷气大脑</del>JetBrains的IDEA，通过自带的Spring Initializer就能够十分轻松地创建Spring Boot项目了，不那么简单的其实是完全不清楚那一大堆依赖项都有什么作用，也不知道一个简单的项目首先需要用到哪些依赖。实话说，在私下经历了几次重开之后我才算琢磨明白要用到哪些依赖，也算是规划好项目的层次结构了。</p><h2 id="万物起源：登陆"><a href="#万物起源：登陆" class="headerlink" title="万物起源：登陆"></a>万物起源：登陆</h2><p>对所有的信息管理系统来说，登录功能几乎是这类软件功能的基石，所有的用户角色、权限，所有的实体功能都要建立在用户一登录的基础上。如果没有一套较为完整的登录流程，整个系统便无从运行。</p><p>在前几个学期，我做过一个要求不高的课设，那时候还没有要求设计UI，也没有任何数据库，只是简简单单地通过C++标准库的 <code>fstream</code>把信息写进文件，想实现登录只需要做一个判断即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(username == input_name &amp;&amp; password == input_password)<span class="hljs-comment">// 判断用户名和密码是否匹配</span><br></code></pre></td></tr></table></figure><p>但是现在不一样，现在有数据库，每当前端传来用户名和密码，都需要通过用户名和密码向数据库查询是否存在该用户，同时考虑到用户离职，但是不能够简单地将其从数据库中删除，这样会影响到后续的的数据统计，因此需要另设置用户的“在职”识别码，说白了就是个<code>boolean</code>变量，进而通过判断该用户是否在职来确定是否允许该登录请求通过。而且通常情况下咱们登录一个网站后，这个登录状态其实是有期限的，过期后就需要重新登录，这说明我们需要一个地方来保存下每个登录用户的登录状态，这个登录状态包含了用户的非敏感的登录信息，并且这个登录状态必须是唯一的，以此来保证这个登录状态不会被重复利用。</p><p>这种场景有一个专门的名字：<strong>跨域身份验证</strong>。其中比较主流的方式是JWT，即JSON Web Token：在前端发起登录请求后，服务端会通过登录信息来构建一串token作为该用户本次登陆的唯一凭证，这个token会被前端保存下来，之后的每次请求中都会携带token，由服务端来校验token是否合法，进而决定是否要执行功能代码。而这个token会采用一定的认证算法将携带的信息载荷加密形成签名，一旦载荷被修改，签名则立即发生变化，这样服务端获取token后只需通过载荷与约定的认证方式来计算出签名进行比对即可。</p><p>具体到JWT的实现上，虽然自己从头写一个工具类不算困难，但事实上有许多细节是需要考虑的，而且一个成熟的工具类需要后续不间断的维护和更新，所以本着非必要不造轮子的原则，比较著名的JJWT和 Java-JWT包都是不错的选择。在使用了JJWT后，我个人还是比较推荐Java-JWT，感觉它的限制会少一些，可以将token验证流程控制得更加精细。</p><h2 id="城门卫士：拦截器"><a href="#城门卫士：拦截器" class="headerlink" title="城门卫士：拦截器"></a>城门卫士：拦截器</h2><p>所谓拦截器，在这个小项目中最主要的作用是拦截所有登录之外的请求，只有用户登录情况正确后才能执行相应的功能。在Spring Boot中，SpringMVC已经为我们提供了拦截器，称为<code>HandlerInterceptor</code>，其下有三个方法声明，分别为 <code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>，分别用于在<code>Controller</code>方法执行前、<code>Controller</code>方法执行后而 <code>ModelView</code>渲染前、<code>ModelView</code>渲染后。由于项目中只用到了<code>preHandle</code>，因此先简单介绍一下这个方法。</p><p>方法包含3个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpServletRequest request, HttpServletResponse response, Object handler<br></code></pre></td></tr></table></figure><p><code>request</code>是当前服务端收到的请求</p><p><code>response</code>是当前的响应</p><p><code>handler</code>可以认为是<code>Controller</code>方法的整个方法签名</p><p>接着描述一下拦截的逻辑：首先我们需要实现<code>HandlerInterceptor</code>类并重写<code>preHandle</code>方法，在方法体中，首先获取token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br></code></pre></td></tr></table></figure><p>去具体判断何时应当认为token是符合约定的，即什么条件下允许服务端执行用户请求的功能。</p><p>随后，需要针对新增的拦截器添加配置，这一点通过Spring Boot的配置类来实现，我们需要做的有：</p><ol><li><p>实现<code>WebMvcConfigurer</code>接口</p></li><li><p>重写<code>addInterceptors</code>方法</p></li><li><p>方法中添加配置代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>   registry.addInterceptor(loginInterceptor)<br>         .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 拦截路径</span><br>         .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 排除路径</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这样，拦截器便可以根据路径启用对应的拦截。</p><h2 id="和而不同：跨域"><a href="#和而不同：跨域" class="headerlink" title="和而不同：跨域"></a>和而不同：跨域</h2><p>什么是跨域？当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。而在我们的课设项目中，前端与后端的端口分别为8080和8888，因此当前端发出一个请求时，请求的url端口号是8888，而当前页面url的端口号则是 8080，这就形成了跨域。</p><p>浏览器默认是不允许跨域的，这源于浏览器的同源策略。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><p>先不用关心如果没有同源策略的限制将会使前后端交互出现什么安全性问题，现在只需要知道同源策略能够在一定程度上规避一些危险，但却使开发人员需要额外考虑跨域问题，而跨域解决方案的执行对象则比较宽松，既可以由前端来做，也可以由后端来实现。而项目中前端的数据渲染是重中之重，因此就决定将所有看不见的部分都交给后端来考虑。</p><p>在Spring Boot中，由于它已经为我们定义好了相关的接口，因此我们需要做的有：</p><ol><li><p>实现<code>WebMvcConfigurer</code>接口</p></li><li><p>重写<code>addCorsMappings</code>方法</p></li><li><p>在方法中添加配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>        .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)<br>        .allowCredentials(<span class="hljs-literal">true</span>)<br>        .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>        .maxAge(<span class="hljs-number">3600</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p><strong>但是</strong>事实上，当我做完这一切以为只剩下前端负责的工作时，功能测试立马就出了问题：由于我没有前端来做真实测试，只好通过Postman来做请求测试后端功能，全无问题，然而但前端完成渲染后开始测试时却出现了接连不断的<code>500 error</code>，大家伙儿对着浏览器F12瞪了半天没看出来究竟是哪里的问题。很无奈，只能在百度上瞎猫碰上死耗子一般地搜索关键词，想不到还真能碰上记录了相同问题的文章，在这里感谢文章<a href="https://www.cnblogs.com/penghq/p/13163779.html">springboot拦截器导致@CrossOrigin失效</a>。</p><p>其<strong>原因</strong>在于：CORS复杂请求时会首先发送一个<code>OPTIONS</code>请求做嗅探，来测试服务器是否支持本次请求，请求成功后才会发送真实的请求；而<code>OPTIONS</code>请求不会携带数据，导致这个请求被拦截了，直接返回了状态码，响应头中没携带解决跨域问题的头部信息，出现了跨域问题。</p><p>知道了原因，那么<strong>解决方法</strong>其实在非常简单，只需要在拦截器中首先检查请求的方法是否为<code>OPTIONS</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于配置了跨域，如果拦截的是预检的OPTIONS请求，则放行</span><br><span class="hljs-keyword">if</span> (request.getMethod().equalsIgnoreCase(<span class="hljs-string">&quot;OPTIONS&quot;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h2 id="天下太平：统一异常处理"><a href="#天下太平：统一异常处理" class="headerlink" title="天下太平：统一异常处理"></a>天下太平：统一异常处理</h2><p>在前后端分类的项目中，前后端的通信就都是依靠请求和响应报文来实现，因为关于计算机网络底层的那些通信协议由操作系统和框架帮助我们搭好了脚手架，所以站在业务开发的角度，我们只需要考虑以怎样的统一格式来规范请求和响应报文。</p><p>在我们的项目中，对于请求体而言，由于Spring Boot提供的<code>@RequestBody</code>注解能够将JSON字符串封装为定义好的类，因此只需要针对一个或多个功能请求设计一个对应的实体请求类：</p><p>例如对于登录功能而言，请求体中必然包含<code>userID</code>以及<code>password</code>字段，因此就可以定义<code>LoginRequest</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginRequest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String userID;<br>    <span class="hljs-keyword">private</span> String password;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Controller</code>响应的方法参数中获取这个类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseResult&lt;Object&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginRequest loginRequest)</span> &#123;<br>        <span class="hljs-comment">// 从loginRequest中获取信息执行登录操作</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>而响应体则不像请求体那么多变，响应体可以抽象为具有统一格式的实体类，由<strong>响应码</strong>、<strong>消息</strong>、<strong>数据</strong>三部分组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseResult</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">// 响应码，类似与HTTP code，但能够传递更加明确的信息。</span><br>    <span class="hljs-keyword">private</span> String msg; <span class="hljs-comment">// 响应码代表的消息，前端可以通过响应码和提示消息共同判定用户请求是否存在异常，</span><br><br>    <span class="hljs-keyword">private</span> T data; <span class="hljs-comment">// 由于要传输的数据类型会根据需要的不同而变化，因此采用泛型。</span><br><br>    <span class="hljs-comment">/* 包含部分参数的构造方法 */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>说了这么多，其实都是在为<strong>统一异常处理</strong>设下铺垫。我们时长能看到有时候网页提示各种错误，比如<code>404</code>、<code>500</code>、<code>502</code>……当然这些基本上都是后端的服务器本身出了问题，但是在实际的场景中，服务端代码抛出的异常并非都由系统异常引起，相反，大部分异常都是由<strong>不合理的请求</strong>或者<strong>错误的代码逻辑</strong>引起的，而这些异常如果直接返回给前端甚至用户，用户并不知道究竟是什么地方出了问题，本着<strong>自己的锅自己背</strong>的原则，统一异常处理就体现得很有必要而且格外优雅了。</p><p>在Spring Boot中，存在专门的异常处理机制，通过在类上添加<code>@ControllerAdvice</code>注解告诉 Spring这是一个异常处理类，可以捕获项目中抛出的所有异常，在异常处理方法中，可以通过添加<code>@ExceptionHandler</code>注解来声明该方法用于处理哪种异常。</p><p>具体到课设项目，在拦截器中，如果token验证不通过，则会直接抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid Token&quot;</span>);<br></code></pre></td></tr></table></figure><p>在异常处理流程中，通过判断<strong>异常所携带的信息</strong>是否与<strong>所期望的信息</strong>相同来决定向前端返回怎样的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginControllerAdvice</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(RuntimeException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseResult&lt;Object&gt; <span class="hljs-title function_">loginControllerAdvice</span><span class="hljs-params">(RuntimeException e)</span> &#123;<br>        <span class="hljs-comment">// 获取异常信息，如果与约定的异常信息相等则认为是登录异常，返回响应体，否则直接返回异常信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> e.getMessage();<br>        <span class="hljs-keyword">if</span> (message.equals(<span class="hljs-string">&quot;Invalid Token&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseResult</span>&lt;&gt;(<span class="hljs-number">10401</span>, <span class="hljs-string">&quot;Invalid Token&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseResult</span>&lt;&gt;(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交流共享：接口文档"><a href="#交流共享：接口文档" class="headerlink" title="交流共享：接口文档"></a>交流共享：接口文档</h2><p>写到这里，技术上想说的大部分都说完了，接口文档主要是为了方便前端开发，将所有接口的JSON规范以实例的形式展现出来，这样前端则只需要根据JSON格式来构造请求和渲染视图，而在测试出现问题时，前后端联调也更容易定位到bug所在的接口。在这一点上，开发过程中我是深有体会的，而事实上我写的接口数量要比实际上前端用到的要多，因此这份文档甚至在些报告的时候也帮助我确定了哪些接口没有用过，即不需要在报告中体现的部分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是Spring Boot给我留下的第一印象了，不愧是Java Web领域的头把交椅，更新的速度也是飞快。</p><p>当然，我这种“跳级”的学习方式是绝对不推荐的，要不是为了能够不用每次课设都挖新坑，我肯定更愿意去了解一下计算机语言本身的魅力，毕竟人们都说程序员的三大浪漫是<strong>编译原理、图形学和操作系统</strong>，这一学期算是一次性摸遍了这三个领域，操作系统对我而言没有太多感触，可能是因为我学得不认真吧，图形学用的是古老的GLUT图形库，说实话就是——没什么好说的，而编译器的魅力则是吸引我很久了，只是手造语法分析总是让我感觉不得要领。好了说回来，Java Web的学习路线还是有些坡度的，对于想走这Java Web这条路的初学者，我从一个同为初学者角度来说还是建议从HTTP、Servlet等基础开始学习，毕竟根基不牢易遭反噬不是吗？</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0919：随想</title>
    <link href="/2021/09/19/0919-thinking/"/>
    <url>/2021/09/19/0919-thinking/</url>
    
    <content type="html"><![CDATA[<p>——“我确实对那些高大上的技术没有很高涨的兴趣，唯独希望设计几个有影响力的小作品，或针对开发者，或针对在校学生。”</p><span id="more"></span><hr><h2 id="0x0000A000"><a href="#0x0000A000" class="headerlink" title="0x0000A000"></a>0x0000A000</h2><p>——我想我永远不会忘记第一次在一个学编程的网站上成功运行 <code>printf(&quot;Hello World!&quot;);</code>的那一刻，那时我切身地感到面前的电脑此刻才真真正正属于自己。</p><h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><p>这学期有一门听起来比较有意思的课程，<strong>关于企业开发</strong>，其实我蛮早就对这门课有所好奇，感觉能够学到一些实践性更强的技术，而不是像学校里一学期C++一学期Java一学期C#还都只是学到面向对象。后来，加入了负责老师建立的课程群，了解到学校会请一些企业工程师或高管来做讲座，之后便在暑假末期通过腾讯会议开办了2场讲座，然而在听过这2场的内容后，我却不太想开学了。</p><p>第一场讲座，嘉宾是一位来自微软的工程师，毫无悬念地，这是一场持续3个小时的.NET框架和及相关介绍，我不知道这听几个小时有什么作用，我只知道B站有大把的.NET教程；第二场讲座，来者是一位证券公司的系统开发工程师，先不管是金融机构还是互联网公司，只要是系统开发，那讲的就是系统架构了，于是再一次毫无悬念地领教了信息管理系统的架构层级。</p><p>但开学终究还是来了，第三次的讲座内容几乎与代码层面的技术没有什么关系，看到了一位实现了财务自由的技术转金融的35岁投资人介绍AI如何进入宝马工厂的汽车生产过程，还探讨了一点大学生活。实话说，没有我看到一个不错的JavaScript教程时激动。</p><p>终于，我不再期待第四场讲座了。</p><h3 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h3><p>写到这里，倒不是说我看不起这样的讲座，只是这些内容即便是对于被迫来到CS专业的学生来说，也是一些常常会在信息流中被浏览到的知识，或许知乎上随便逛逛就会看到今天AI技术又被运用在了什么产业，百度上搜一个关键词就有CSDN的讲解，微博热搜就有各类科技新闻，甚至关注的公众号也会推送一些前沿科技的现状。相较而言，这几场讲座的受众，应当是在计算机领域里比我们更加普通的人。至少，对我来说，这种介绍性的内容并不合我的胃口。</p><p>私认为像这样的课程，既然被冠以“企业”二字，那就应该教一些企业开发的相关技术或讲述一些企业开发领域的要点：Git入门、设计模式、WebApp、JavaEE、敏捷开发、持续交付……如果我是负责老师，我想我会将这门课作为让学生统一接触企业的形式。我大约只会请5位左右的企业工程师，针对某一技术栈，比如前端工程化，比如JavaEE，比如小程序开发。我会请这几位工程师成立一个暂时的开发团队，自拟一个项目，接着做好项目架构与技术选型，先做一次以前期准备为主题的讲座，说明课程的任务和要求，然后带领学生以分组开发的形式来开展课程，每组负责一个功能模块，由一位工程师担任组长，以每周开组会的形式进行项目的推进。每位学生需要做好周报，对每周的开发做一个总结，而作为考核，在期末时每个小组需要撰写一份课设报告，描述小组所负责的模块与开发过程。</p><h3 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h3><p>诚然上述看法显得我看不起这种讲座，但我并不是说厌恶这类对“高能”技术的介绍。然而对于我这样一个并没有系统地接触过一次<strong>从零开发项目</strong>的过程的人来说，马上就研究人工智能这种高端技术实在是有些不切实际，因此我也并没有选择这学期的机器学习选修课，而退一步说，短短三个小时也难以厘清.NET的整条技术栈，何况至少目前我并不对Windows开发有很浓厚的兴趣。我更加喜欢那种技术性更强、实践性更好的课程，即便是纯理论，我也认为需要搭配上实操，只有当自己在真实的系统环境上操作过才能体会到理论是如何服务应用场景的。</p><p>正因为我深知现在的自己实在是没有什么开发经验，所以才不愿意马上就接触那些高层次的、面向未来的理论和应用，而是更希望去实际地学习几项企业开发的技能，作为一名预备程序员，代码能力应当是首要的，否则拿什么去支撑起自己的ideas呢？其余的那些设计思想或是算法，也都是以服务开发过程为目标的。仔细想想，如果学习这么多的理论，但是却没有足够的能力支持自己开发一个作品，做不出一个完整的项目，那是一件令人挫败的事情。</p><p>很不幸，我现在就是这样。</p><h2 id="0x0000A001"><a href="#0x0000A001" class="headerlink" title="0x0000A001"></a>0x0000A001</h2><p>——从那一行C语言代码开始，关于这些代码如何运行而变成一句<code>&quot;Hello World&quot;</code>这件事，我有着浓厚的兴趣，并且，对于我想开发的作品，我所拥有的一切幻想，也从这一行代码开始。</p><h3 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h3><p>尽管我支持<strong>用实践帮助学习理论</strong>的观点，但是在以往的几个学期里，有太多莫名其妙的实验课，当然并非是实验课本身没有存在的必要，而是必须要写的实验报告，用无趣又无情的格式要求消磨掉了很多时间。那些我可以用来学习兴趣所在的时间，都变成了抄写实验要求，变成了手抄实验代码，变成了胡编实验小结，变成了没有问题也要想出几个问题来写上去，这就是无意义的形式主义吧，不加限制就会发展为内卷，而我们又不得不加入内卷。然而在漩涡里两年了，我也没有卷死过什么人，但自己却是感受到了危机，真的，看起来学了很多知识，但是我不知道怎么开发一个项目，我不知道怎么实现我幻想中的产品，我好像有一个大致的思路，意思是我应该知道我想要的东西会长成什么样子，但是我不知道怎么去塑造它。</p><p>以前看过一篇教育文章，家长们很不理解为什么孩子会陷入游戏而不爱学习，“要是把你玩游戏的精力用到学习上你成绩早就上去了”，实际上从游戏和学习的本质来看，它们的核心相同点就是你需要靠一定的努力去获得一定的成果。游戏中可以升级，可以赚经验，可以赚金币银币，一场游戏下来所获得的成就就很可观，因此激励玩家快速投入下一场游戏，但是学习不一样，通过学习获得一定的成果，这个过程远比打游戏要漫长得多。试想，你玩的游戏在某个阶段升级需要几百万经验，而一场游戏赢了也不过只能获取最高一千出头的经验，在一个等级停留了几百场甚至千场，那种无力感肯定会让你肯定会想不通：“这游戏是认真的吗？！”当我在抄写实验指导书上的那些要求和大段的实验代码时，我就有这种无力感。我不是那种有能力搞内卷的人，我不愿意参加那些奇怪的学校活动，也不想参加什么专业无关的比赛，但是综测会参与到奖学金评选，我很容易被别人靠综测反杀，但是的但是，我真的想多琢磨琢磨我的fantasy。</p><p>暑假伊始时我给自己列了一份很现实的清单，记录了一些我想学的技能，但是不曾想暑假里发生了<strong>一连串我无法预知的事情</strong>，我知道，这一系列计划都不得不中断，意味着虽然我无需抱怨那该死的实验，但我依然有两个月时间无法集中精力做我该做的事情。假期中至少一半的时间里，我晚上都会出门溜达，我不喝酒，所以买瓶盐汽水，碳酸刺激口腔与喉咙的感觉才将我拉回现实中，那是我不可多得的清静时光。</p><p>毫无疑问，到开学时我的危机感更重了。</p><h3 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h3><p>新一学期终究还是到来了，我面临的是更重要的专业课，以及不那么有趣的选修课，还有一些课程设计和值得参加的比赛，是的，我终于明白自己应该去参加一些比赛。那些已经板上钉钉的事情我是没什么办法去改变的，有些无意义的东西我也不再想去做了，专注于我感兴趣的事情去做吧。我一直觉得学开发做开发就像玩游戏一样是一件见效很快的事情，甚至比打游戏获益的效率更高：写真真实实的代码，实现真真实实的功能。</p><p>前几天，朋友给我发了一串聊天截图，对方是今年保研资格的学长，有竞赛，有软著，有科研……对于保研，我可能深知自己几斤几两，但是那份软著却真正拨动了我心中的某一根弦，就像开头说的一样，我希望开发出几个有意思的、有实际意义的作品，对开发者或者大学生有用的应用。也许我会将其统统开源，如果能在自己的开源代码上成立商业项目，说不定我就能以此创业，当然做个打工人也没什么不好的，只是我应该会保留有这一份心，支撑我现在的学习。</p><p>雷军和尤雨溪一直是我愿意看向的人。</p><h2 id="0x0000A002"><a href="#0x0000A002" class="headerlink" title="0x0000A002"></a>0x0000A002</h2><p>——但愿我有时间去慢慢填补我挖给自己的坑，堆成一座山，蓄起一条河，养好一方人。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年终总结</title>
    <link href="/2021/01/25/2020-year-end-review/"/>
    <url>/2021/01/25/2020-year-end-review/</url>
    
    <content type="html"><![CDATA[<p>旧岁即去，年关将至，对于一个<del>新来的</del>博客人来说，总觉得要写点什么来让这一年在自己的脑海中留下一些印象。</p><span id="more"></span><hr><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>因为在去年暑假期间才稍稍规划了一下，决定开始逐步构建博客的内容。而做出这个决定时已经到了下半年，于是随着下半年的顺利开学，整个博客也因为学业繁忙而不能再更新，就连使用的框架都已经更迭了很多个版本。如今放假没几天，重装了系统的我基本安装好了需要的环境，生活也逐渐有了节奏，于是思考着将博客整体翻修一遍吧，翻修的过程其实比较枯燥，无非就是跟着文档一点一点改图标、背景、文字、标识，没什么好写的，而真正的重点在于——我觉得现在应该写点什么。因为别的日程还需要一两天来规划，而无论从期末还是年末的角度来说，这都是一个有意义的时间段。我想，既然别的大佬们都会在每年末做一个年终总结，那我也来“装模作样”地总结一下属于我的2020。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>焦虑。</p><p>整个2020上半年，可以说我都是有些焦虑的。这种焦虑比较特别，不是说我在焦虑什么，而是我不知道在焦虑什么，疫情的蔓延会让我焦虑，有些无厘头的课会让我焦虑，催命般的每日上报体温会让我焦虑……虽说都不是什么严重的大事，但每天都要一个接一个地遇到这些事儿就是会很不爽，比每天满课更感压抑，尤其是许多非专业相关的课，又不想上，又不敢不签到，真是糟心。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>痴呆。</p><p>倒不是说我脑子不正常，而是发现这种人情世故的变化一下子好快，有人分开，有人牵手，对此我其实并没有什么想法，但是在看到有小俩口儿一起去旅游时，我脑子里仿佛有什么东西一下子突破了，原来我们早就到了自由恋爱的年纪，再也没有刑法之外的顾忌，好像就是在一瞬间，我想通了这一点，然后只觉我好痴呆，“小丑竟是我自己”。但这样一个念头确让我想通许多，往大了说，在世界各地的同学朋友们都有太多的可能，未来都有太多的变数，有大佬写歌，有大佬做AI，有大佬玩特技……好像只有我上课之外什么支线活动都没有了，为了一个小小的梦想还要储备太多太多的基础。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>时间终于来到了下半年，整个暑假可算是能够让我好好放松一下，也有了构建这个博客的想法，不过因为想法产生得比较晚，所以直到八月中旬才有了两条内容。而很快又正常开学了，这学期中技术型的东西并不多，学的不是数学物理这样的理论就是一些基础的编程语法和思想皮毛，专业课上障碍不算大，倒是那些理论基础课都挺难的，时间也就都花在了这些基础课上，自然而然的也就没什么时间去进一步学专业相关的内容，博客也是刚刚起步就中断了更新。这一学期总体来说我只觉得不习惯，在所有的方面都感觉到不习惯。一方面可能是在家里确实待久了， 一方面是繁杂的课实在太多了，利用一样工具完成作业的同时要学习这样工具该如何去使用，也只有在那两堂编程实验课上我觉得稍稍得心应手一些。完成作业与搞懂这些结论的确让我感受到真真实实的压力，以至于到了期末我只觉得像久病撒手一般的解脱，终于可以肆无忌惮地放任自己的懒惰。</p><p>自九月开学，就特别盼望国庆假期，仿佛那是德爷在丛林中的草原上搭建的shelter，是个避难的地儿，我能够闭上眼回味一下自己，再把某天摔碎的手机去送修，然后并不是像德爷一样最后重返文明世界，而是又被甩进大海继续漂流。</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>年终了，也意味着新一年的即将开始，又到了一年一度的 <del>画饼</del> 做规划的日子，于是趁着寒假的头上把出了两个月毛病的电脑重装了一下，还有各种app和软件依赖也基本安装到位了，也算是某种程度上的“以崭新的面貌面对新的一年”吧。</p><p>事实上我还没有画什么饼，而且我认为我也画不出什么大饼。我一直觉得自己不是那种擅长做很清晰的规划的人，顶多就是这两天我该干什么，或者是在一段时间里有一个很模糊的目标，可能这就是期末那几天我活得如此狼狈的原因吧，不过好在狼狈到底还是起了一点作用，也不算枉费几个晚上吧。但说真的我是不愿意再这么整了，况且也不是什么好方法，是该整顿一下自己了。</p><p>打字的这几个晚上，世界上有许多事情发生，疫情也有所反复，记得在年末的时候大家都在期望2021能好过一些，但目前来看，2020的余孽还没有消散，2021的美好距离我们还有一些距离。</p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p>over！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于PowerShell跑不了Nodejs脚本的解决方法</title>
    <link href="/2021/01/23/solve-Powershell-cannot-run-Nodejs/"/>
    <url>/2021/01/23/solve-Powershell-cannot-run-Nodejs/</url>
    
    <content type="html"><![CDATA[<p>“因为在此系统中禁止执行此脚本。”</p><span id="more"></span><hr><p>解决方法：</p><p>以管理员身份运行 <code>powershell</code></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">set-ExecutionPolicy</span> <span class="hljs-string">RemoteSigned</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Y</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在看完小米十周年发布会后</title>
    <link href="/2020/08/12/after-xiaomi-10-year-release-conference/"/>
    <url>/2020/08/12/after-xiaomi-10-year-release-conference/</url>
    
    <content type="html"><![CDATA[<p>——“等待下一个技术BigBang的时机”</p><span id="more"></span><hr><p>作为一个科技数码产品爱好者，在看了几年的各种手机电脑评测、经历了一次又一次心动感动和不为所动之后，认清了每一款旗舰产品在其发布的那个时代里都不是百分百完美的，甚至相较于其发布前的一段时间也是不够完美的。</p><p>而如今电子产品更新换代速度越来越快，性能提升也不再惊人，将这种&#x2F;发布会带来的重磅&#x2F;与&#x2F;很短时间后新产品带来的变革&#x2F;之间的落差&#x2F;对购买欲造成的忐忑&#x2F;扩大了不少，即对下一代产品的期待降低了对这一代产品的购买欲，所以我曾经梦想着自己有朝一日能够有机会使用每一款我感兴趣的设备，而不用担心自己有没有钱买，或者，进入自己喜欢的产品所属的公司和企业来实现我的梦想。</p><p>在那时，我是个绝对的参数党，对于软件方面没有很多看法，只要硬件参数够顶就可以为它买单，但随着年龄的增长，手机电脑的应用场景越来越多，我认识到单纯的硬件不能够代表设备的使用体验，在旗舰级别的硬件参数基础上，软件环境更是重中之重，硬件的强大能力需要软件来发挥，高质量的软件环境才能配得上高水平的硬件参数。</p><p>产生这样的心性变化，我想，这大概就是现在我对于软件和系统上的折腾的兴趣要大过整天看手机电脑配置的原因吧，买硬件就像为了装备充钱，做软件就像为了排名练游，游戏实力的提升带来的感受是远比充钱更快乐的，即能力的提升是比外在的满足更充实自我的。买高配电脑，要配得上你对算力的需求，买旗舰手机，要配得上你对使用场景的理解，而这些需求和理解的基础，是你有绝对的实力说服自己购入心仪的产品，说到底还是对自我的提升。</p><p>今年是一个世界变革的节点，对于电子产品来说，也是技术革新的一个节点，我应该会多多专于自己的技术栈，也拾起对硬件的关注，耐心等待下一个技术BigBang的最佳时机。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是如何创建并部署我的hexo blog到gitee</title>
    <link href="/2020/08/09/how-I-build-my-hexo-to-gitee/"/>
    <url>/2020/08/09/how-I-build-my-hexo-to-gitee/</url>
    
    <content type="html"><![CDATA[<p>Blog初开，作为第一篇文章，我想记录一下自己从创建到部署它的全过程，也算是几天试验成果的一个总结。</p><span id="more"></span><hr><p>一开始因为听说 <code>Hugo</code>框架简单得离谱，于是作为一个菜鸡，我就愉快地按照B站找来的教程成功搭建了一个，随后在想为安装的主题添加更多自定义内容时，发现 <code>Hugo</code>主题的文档都不够全面，更像是这些开发者做出来展示自己的，而且主题也都不太符合我的审美，遂弃之。</p><p>当晚决定用 <code>hexo</code>来完成这件事情。吃一堑长一智，这次先去 <code>github</code>上找了一大堆主题，其中发现一个名为 <code>fluid</code>的由国内开发者开发的主题，外观很不错，文档也很全面完整，就决定是它了！</p><hr><h2 id="安装所需环境（Windows-）"><a href="#安装所需环境（Windows-）" class="headerlink" title="安装所需环境（Windows ）"></a>安装所需环境（Windows ）</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 <code>Node.js</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://nodejs.org/zh-cn<br></code></pre></td></tr></table></figure><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <code>Git</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://git-scm.com/download/win<br></code></pre></td></tr></table></figure><h3 id="打开-Powershell，安装-hexo-cli工具包"><a href="#打开-Powershell，安装-hexo-cli工具包" class="headerlink" title="打开 Powershell，安装 hexo-cli工具包"></a>打开 <code>Powershell</code>，安装 <code>hexo-cli</code>工具包</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><hr><h2 id="建立本地博客站点"><a href="#建立本地博客站点" class="headerlink" title="建立本地博客站点"></a>建立本地博客站点</h2><h3 id="我想把博客项目文件夹放在桌面"><a href="#我想把博客项目文件夹放在桌面" class="headerlink" title="我想把博客项目文件夹放在桌面"></a>我想把博客项目文件夹放在桌面</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> desktop/<br></code></pre></td></tr></table></figure><h3 id="建立本地站点，我将其命名为-myblog"><a href="#建立本地站点，我将其命名为-myblog" class="headerlink" title="建立本地站点，我将其命名为 myblog"></a>建立本地站点，我将其命名为 <code>myblog</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init myblog<br><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure><h3 id="启动博客查看初始化情况"><a href="#启动博客查看初始化情况" class="headerlink" title="启动博客查看初始化情况"></a>启动博客查看初始化情况</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo server<br></code></pre></td></tr></table></figure><h3 id="至此，可以看到提示"><a href="#至此，可以看到提示" class="headerlink" title="至此，可以看到提示"></a>至此，可以看到提示</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">INFO  Hexo is running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器打开 <code>http://localhost:4000</code>，可以看到 <code>hexo</code>建站的同时有一个默认主题。</p><hr><h2 id="更改-amp-配置-hexo主题"><a href="#更改-amp-配置-hexo主题" class="headerlink" title="更改&amp;配置 hexo主题"></a>更改&amp;配置 <code>hexo</code>主题</h2><h3 id="检查是否在-myblog目录下"><a href="#检查是否在-myblog目录下" class="headerlink" title="检查是否在 myblog目录下"></a>检查是否在 <code>myblog</code>目录下</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><h3 id="下载-最新-release-版本，解压到-themes目录下并重命名为-fluid。"><a href="#下载-最新-release-版本，解压到-themes目录下并重命名为-fluid。" class="headerlink" title="下载 最新 release 版本，解压到 themes目录下并重命名为 fluid。"></a>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>，解压到 <code>themes</code>目录下并重命名为 <code>fluid</code>。</h3><h3 id="修改博客目录下的-config-yml："><a href="#修改博客目录下的-config-yml：" class="headerlink" title="修改博客目录下的 _config.yml："></a>修改博客目录下的 <code>_config.yml</code>：</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">title:</span> <span class="hljs-string">Skycurtain&#x27;s</span> <span class="hljs-string">Blog</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Skycurtain</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="添加关于页"><a href="#添加关于页" class="headerlink" title="添加关于页"></a>添加关于页</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo new page about<br></code></pre></td></tr></table></figure><h3 id="修改-source-about-index-md，在头部添加-layout-属性"><a href="#修改-source-about-index-md，在头部添加-layout-属性" class="headerlink" title="修改 /source/about/index.md，在头部添加 layout 属性"></a>修改 <code>/source/about/index.md</code>，在头部添加 <code>layout</code> 属性</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br></code></pre></td></tr></table></figure><p>暂时就做这些处理，更多文档详见：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><hr><h2 id="撰写第一篇文章"><a href="#撰写第一篇文章" class="headerlink" title="撰写第一篇文章"></a>撰写第一篇文章</h2><h3 id="新建一篇post"><a href="#新建一篇post" class="headerlink" title="新建一篇post"></a>新建一篇post</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo new post <span class="hljs-string">&quot;我是如何创建并部署我的hexo blog到gitee&quot;</span><br></code></pre></td></tr></table></figure><p>这样在source&#x2F;_post&#x2F;下会新建“我是如何创建并部署我的hexo blog到gitee”的md文件</p><hr><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>首先需要在 <code>gitee</code>新建仓库</p><h3 id="修改-config-yml配置"><a href="#修改-config-yml配置" class="headerlink" title="修改 _config.yml配置"></a>修改 <code>_config.yml</code>配置</h3><p>选择 <code>gitee</code>的原因是 <code>Github Pages</code>的访问速度并不理想，而且暂时也没有考虑各种加速手段，所以尽管 <code>gitee</code>有各种不足，但它仍然成为了我的选择。</p><p>鉴于 <code>Github Pages</code>的后端采用 <code>Jekyll</code>，或许以后等我的博客成熟了会考虑迁移到 <code>Jekyll</code>并部署到 <code>Github Pages</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://gitee.com/skycurtain/skycurtain</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p>用 <code>VS Code</code>打开博客项目并开启终端（确保操作目录是 <code>myblog/</code>）</p><p>配置git信息</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;Skycurtain&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email skycurtain@<span class="hljs-number">163</span>.com<br></code></pre></td></tr></table></figure><p>建立git仓库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git init<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install hexo<span class="hljs-literal">-deployer-git</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo generate<br></code></pre></td></tr></table></figure><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo deploy<br></code></pre></td></tr></table></figure><p>以上两步操作可以简化为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo generate <span class="hljs-literal">--deploy</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo g <span class="hljs-literal">-d</span><br></code></pre></td></tr></table></figure><p>最后在 <code>gitee</code>仓库的服务中选择 <code>Gitee Pages</code>，选择 <code>启动</code>&#x2F;<code>更新</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>关于</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p align="center">一个想在移动端编程领域开拓全新体验的前端混子</p>]]></content>
    
  </entry>
  
  
  
</search>
